<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · CodonMolecularEvolution.jl</title><meta name="title" content="Home · CodonMolecularEvolution.jl"/><meta property="og:title" content="Home · CodonMolecularEvolution.jl"/><meta property="twitter:title" content="Home · CodonMolecularEvolution.jl"/><meta name="description" content="Documentation for CodonMolecularEvolution.jl."/><meta property="og:description" content="Documentation for CodonMolecularEvolution.jl."/><meta property="twitter:description" content="Documentation for CodonMolecularEvolution.jl."/><meta property="og:url" content="https://MurrellGroup.github.io/CodonMolecularEvolution.jl/"/><meta property="twitter:url" content="https://MurrellGroup.github.io/CodonMolecularEvolution.jl/"/><link rel="canonical" href="https://MurrellGroup.github.io/CodonMolecularEvolution.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href><img src="assets/logo.png" alt="CodonMolecularEvolution.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href>CodonMolecularEvolution.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li><li><a class="tocitem" href="difFUBAR/">difFUBAR</a></li><li><a class="tocitem" href="shared/">Shared tools</a></li><li><a class="tocitem" href="dataprep/">Data preparation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/main/docs/src/index.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="CodonMolecularEvolution"><a class="docs-heading-anchor" href="#CodonMolecularEvolution">CodonMolecularEvolution</a><a id="CodonMolecularEvolution-1"></a><a class="docs-heading-anchor-permalink" href="#CodonMolecularEvolution" title="Permalink"></a></h1><h3 id="A-Julia-package-for-popular-and-new-codon-models-of-molecular-evolution."><a class="docs-heading-anchor" href="#A-Julia-package-for-popular-and-new-codon-models-of-molecular-evolution.">A Julia package for popular and new codon models of molecular evolution.</a><a id="A-Julia-package-for-popular-and-new-codon-models-of-molecular-evolution.-1"></a><a class="docs-heading-anchor-permalink" href="#A-Julia-package-for-popular-and-new-codon-models-of-molecular-evolution." title="Permalink"></a></h3><p>Documentation for <a href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl">CodonMolecularEvolution</a>.</p><p>Descendant of <a href="https://github.com/MurrellGroup/MolecularEvolution.jl">MolecularEvolution.jl</a>, specializing in codon models.</p><h3 id="Collection-of-codon-model-methods"><a class="docs-heading-anchor" href="#Collection-of-codon-model-methods">Collection of codon model methods</a><a id="Collection-of-codon-model-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Collection-of-codon-model-methods" title="Permalink"></a></h3><ul><li><a href="difFUBAR/#difFUBAR">difFUBAR</a>: Scalable Bayesian comparison of selection pressure<ul><li>Perform a site-wise comparison of evolutionary pressure between two selected sets of branches.</li><li>Authors: Hassan Sadiq, Venkatesh Kumar, and Ben Murrell (original model development), Patrick Truong (benchmarking), Maximilian Danielsson (performance optimization).</li></ul></li></ul><h3 id="Design-principles"><a class="docs-heading-anchor" href="#Design-principles">Design principles</a><a id="Design-principles-1"></a><a class="docs-heading-anchor-permalink" href="#Design-principles" title="Permalink"></a></h3><ul><li>User-facing<ul><li>Users with no Julia experience should be able to run these models.</li></ul></li><li>Scalability<ul><li>Models should scale to large, real-world datasets. To keep the memory footprint down, we use <code>MolecularEvolution.jl</code>s <code>LazyPartition</code> when possible.</li></ul></li><li>Performance<ul><li>We try to maintain competitive runtimes by using e.g. computational shortcuts and parallelization whenever we can.</li></ul></li></ul><h3 id="Package-Authors-and-Maintainers"><a class="docs-heading-anchor" href="#Package-Authors-and-Maintainers">Package Authors and Maintainers</a><a id="Package-Authors-and-Maintainers-1"></a><a class="docs-heading-anchor-permalink" href="#Package-Authors-and-Maintainers" title="Permalink"></a></h3><p>Maximilian Danielsson and Ben Murrell. Authors for specific models listed above.</p><ul><li><a href="#CodonMolecularEvolution.PiecewiseOUModel"><code>CodonMolecularEvolution.PiecewiseOUModel</code></a></li><li><a href="#CodonMolecularEvolution.ShiftingHBSimModel"><code>CodonMolecularEvolution.ShiftingHBSimModel</code></a></li><li><a href="#CodonMolecularEvolution.ShiftingHBSimPartition"><code>CodonMolecularEvolution.ShiftingHBSimPartition</code></a></li><li><a href="#CodonMolecularEvolution.ShiftingNeHBSimModel-Union{Tuple{C}, Tuple{B}, Tuple{A}, Tuple{Matrix{Float64}, Array{PiecewiseOUModel{A, B, C}, 1}, PiecewiseOUModel}} where {A, B, C}"><code>CodonMolecularEvolution.ShiftingNeHBSimModel</code></a></li><li><a href="#CodonMolecularEvolution.ShiftingNeHBSimPartition-Tuple{ShiftingNeHBSimModel}"><code>CodonMolecularEvolution.ShiftingNeHBSimPartition</code></a></li><li><a href="#CodonMolecularEvolution.difFUBARBaseline"><code>CodonMolecularEvolution.difFUBARBaseline</code></a></li><li><a href="#CodonMolecularEvolution.difFUBARParallel"><code>CodonMolecularEvolution.difFUBARParallel</code></a></li><li><a href="#CodonMolecularEvolution.difFUBARTreesurgery"><code>CodonMolecularEvolution.difFUBARTreesurgery</code></a></li><li><a href="#CodonMolecularEvolution.difFUBARTreesurgeryAndParallel"><code>CodonMolecularEvolution.difFUBARTreesurgeryAndParallel</code></a></li><li><a href="#CodonMolecularEvolution.FUBAR_analysis-Union{Tuple{T}, Tuple{SKBDIFUBAR, FUBARGrid{T}}} where T"><code>CodonMolecularEvolution.FUBAR_analysis</code></a></li><li><a href="#CodonMolecularEvolution.FUBAR_analysis-Union{Tuple{T}, Tuple{FIFEFUBAR, FUBARGrid{T}}} where T"><code>CodonMolecularEvolution.FUBAR_analysis</code></a></li><li><a href="#CodonMolecularEvolution.FUBAR_analysis-Union{Tuple{T}, Tuple{DirichletFUBAR, FUBARGrid{T}}} where T"><code>CodonMolecularEvolution.FUBAR_analysis</code></a></li><li><a href="#CodonMolecularEvolution.HB98AA_matrix-Tuple{Any, Any, Any}"><code>CodonMolecularEvolution.HB98AA_matrix</code></a></li><li><a href="#CodonMolecularEvolution.HB98_row-NTuple{4, Any}"><code>CodonMolecularEvolution.HB98_row</code></a></li><li><a href="#CodonMolecularEvolution.HB_fixation_rate-Tuple{Any, Any}"><code>CodonMolecularEvolution.HB_fixation_rate</code></a></li><li><a href="#CodonMolecularEvolution.HBdNdS-Tuple{Vector{Float64}}"><code>CodonMolecularEvolution.HBdNdS</code></a></li><li><a href="#CodonMolecularEvolution.HBviz-Tuple{Vector{Float64}, Vector{Vector{Float64}}, Float64, Any, Any}"><code>CodonMolecularEvolution.HBviz</code></a></li><li><a href="#CodonMolecularEvolution.benchmark_global_fit-Tuple{Any}"><code>CodonMolecularEvolution.benchmark_global_fit</code></a></li><li><a href="#CodonMolecularEvolution.benchmark_grid-Tuple{Any}"><code>CodonMolecularEvolution.benchmark_grid</code></a></li><li><a href="#CodonMolecularEvolution.dNdS-Tuple{Any, Any, Vector{Float64}}"><code>CodonMolecularEvolution.dNdS</code></a></li><li><a href="#CodonMolecularEvolution.difFUBAR-NTuple{5, Any}"><code>CodonMolecularEvolution.difFUBAR</code></a></li><li><a href="#CodonMolecularEvolution.difFUBAR_init-Tuple{Any, Any, Any}"><code>CodonMolecularEvolution.difFUBAR_init</code></a></li><li><a href="#CodonMolecularEvolution.difFUBAR_tabulate_and_plot-NTuple{7, Any}"><code>CodonMolecularEvolution.difFUBAR_tabulate_and_plot</code></a></li><li><a href="#CodonMolecularEvolution.generate_ambient_indices-Tuple{Int64}"><code>CodonMolecularEvolution.generate_ambient_indices</code></a></li><li><a href="#CodonMolecularEvolution.generate_fubar_indices-Tuple{Int64}"><code>CodonMolecularEvolution.generate_fubar_indices</code></a></li><li><a href="#CodonMolecularEvolution.getpuresubclades-Tuple{MolecularEvolution.FelNode, Vector{String}}"><code>CodonMolecularEvolution.getpuresubclades</code></a></li><li><a href="#CodonMolecularEvolution.import_colored_figtree_nexus_as_tagged_tree-Tuple{Any}"><code>CodonMolecularEvolution.import_colored_figtree_nexus_as_tagged_tree</code></a></li><li><a href="shared/#CodonMolecularEvolution.import_colored_figtree_nexus_as_tagged_tree"><code>CodonMolecularEvolution.import_colored_figtree_nexus_as_tagged_tree</code></a></li><li><a href="shared/#CodonMolecularEvolution.import_grouped_label_tree"><code>CodonMolecularEvolution.import_grouped_label_tree</code></a></li><li><a href="#CodonMolecularEvolution.import_grouped_label_tree-Tuple{Any}"><code>CodonMolecularEvolution.import_grouped_label_tree</code></a></li><li><a href="shared/#CodonMolecularEvolution.import_labeled_phylotree_newick"><code>CodonMolecularEvolution.import_labeled_phylotree_newick</code></a></li><li><a href="#CodonMolecularEvolution.import_labeled_phylotree_newick-Tuple{Any}"><code>CodonMolecularEvolution.import_labeled_phylotree_newick</code></a></li><li><a href="#CodonMolecularEvolution.jump-Tuple{Any, Any, PiecewiseOUModel}"><code>CodonMolecularEvolution.jump</code></a></li><li><a href="#CodonMolecularEvolution.jumpy_HB_codon_evolve-NTuple{6, Any}"><code>CodonMolecularEvolution.jumpy_HB_codon_evolve</code></a></li><li><a href="#CodonMolecularEvolution.jumpy_NeHB_codon_evolve-NTuple{6, Any}"><code>CodonMolecularEvolution.jumpy_NeHB_codon_evolve</code></a></li><li><a href="#CodonMolecularEvolution.maxdNdS2std-Tuple{Any}"><code>CodonMolecularEvolution.maxdNdS2std</code></a></li><li><a href="#CodonMolecularEvolution.optimize_MG94_F3x4-Tuple{Any, Any, Any}"><code>CodonMolecularEvolution.optimize_MG94_F3x4</code></a></li><li><a href="shared/#CodonMolecularEvolution.optimize_MG94_F3x4"><code>CodonMolecularEvolution.optimize_MG94_F3x4</code></a></li><li><a href="#CodonMolecularEvolution.shiftingHBviz-NTuple{6, Any}"><code>CodonMolecularEvolution.shiftingHBviz</code></a></li><li><a href="#CodonMolecularEvolution.shiftingNeHBviz-NTuple{10, Any}"><code>CodonMolecularEvolution.shiftingNeHBviz</code></a></li><li><a href="#CodonMolecularEvolution.sim_alphabeta_seqs-Tuple{Vector{Float64}, Vector{Float64}, Any, Matrix{Float64}, Matrix{Float64}}"><code>CodonMolecularEvolution.sim_alphabeta_seqs</code></a></li><li><a href="#CodonMolecularEvolution.std2maxdNdS-Tuple{Any}"><code>CodonMolecularEvolution.std2maxdNdS</code></a></li><li><a href="#CodonMolecularEvolution.time_varying_HB_freqs-NTuple{4, Any}"><code>CodonMolecularEvolution.time_varying_HB_freqs</code></a></li><li><a href="#MolecularEvolution.forward!-Tuple{ShiftingNeHBSimPartition, ShiftingNeHBSimPartition, ShiftingNeHBSimModel, MolecularEvolution.FelNode}"><code>MolecularEvolution.forward!</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodonMolecularEvolution.PiecewiseOUModel" href="#CodonMolecularEvolution.PiecewiseOUModel"><code>CodonMolecularEvolution.PiecewiseOUModel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PiecewiseOUModel(event_rate::Float64, eq_std::Float64, mixing::Float64; delta_t = 1.0)
PiecewiseOUModel(offsets::Vector{Float64})
PiecewiseOUModel(event_rate::Float64, eq_std::Float64, mixing::Float64, mu::Union{Float64,Vector{Float64}}, offsets::Union{Float64,Vector{Float64}}, codon_offsets::Union{Float64,Vector{Float64}})</code></pre><p>A piecewise constant approximation to an OU process, intended to simulate fitnesses evolving over phylogenies. The equilibrium standard deviation is directly parameterized (<code>eq_std</code>), as is the rate at which the process mixes to equilibrium (<code>mixing</code>). <code>event_rate</code> controls how often the fitness changes occur, where the mixing rate is scaled to compensate for the increased rate of change to achieve approximately the same amount of change per unit time even as the <code>event_rate</code> changes. A very high <code>event_rate</code> will behave more like continuous diffusion, but will be more computationally expensive to sample from. <code>mu</code> can also be set to control the mean fitnesses. The model also permits <code>offsets</code>, which are added to the fitnesses as they are passed into the model. For a single process, these are confounded with the mean <code>mu</code> but if the offsets change (eg. from one branch to another) the effective fitnesses will immidiately change, whereas if <code>mu</code> changes the fitnesses will drift towards <code>mu</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/57d06a39e2f1978b2332b075dc3fb8522ce88084/src/simulations/ou_hb.jl#L79-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodonMolecularEvolution.ShiftingHBSimModel" href="#CodonMolecularEvolution.ShiftingHBSimModel"><code>CodonMolecularEvolution.ShiftingHBSimModel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ShiftingHBSimModel(sites, alphas, ou_params, nuc_matrix; rescale = true)</code></pre><p>A model for simulating fitnesses evolving over phylogenies using the HB98 model. <code>sites</code> is the number of sites, <code>alphas</code> is a vector of synonymous rates (one per site), <code>ou_params</code> is a vector of <code>PiecewiseOUModel</code>s (one per site), and <code>nuc_matrix</code> is the symmetric nucleotide substitution matrix (shared across sites). If &#39;rescale&#39; is true, then the nuc matrix is scaled so that, when <code>alpha=1</code> and the fitnesses<code>=0</code>, the HB model expects one substitution per site per unit time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/57d06a39e2f1978b2332b075dc3fb8522ce88084/src/simulations/ou_hb.jl#L211-L217">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodonMolecularEvolution.ShiftingHBSimPartition" href="#CodonMolecularEvolution.ShiftingHBSimPartition"><code>CodonMolecularEvolution.ShiftingHBSimPartition</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ShiftingHBSimPartition(model::ShiftingHBSimModel; burnin_time = 100.0, code = MolecularEvolution.universal_code)</code></pre><p>Constructs a partition that tracks evolving fitnesses and codons. Only useable for sampling (not likelihood calculations).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/57d06a39e2f1978b2332b075dc3fb8522ce88084/src/simulations/ou_hb.jl#L232-L236">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodonMolecularEvolution.ShiftingNeHBSimModel-Union{Tuple{C}, Tuple{B}, Tuple{A}, Tuple{Matrix{Float64}, Array{PiecewiseOUModel{A, B, C}, 1}, PiecewiseOUModel}} where {A, B, C}" href="#CodonMolecularEvolution.ShiftingNeHBSimModel-Union{Tuple{C}, Tuple{B}, Tuple{A}, Tuple{Matrix{Float64}, Array{PiecewiseOUModel{A, B, C}, 1}, PiecewiseOUModel}} where {A, B, C}"><code>CodonMolecularEvolution.ShiftingNeHBSimModel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ShiftingNeHBSimModel(nuc_matrix, unscaled_ou_params, logNe_model; alpha, rescale, code)</code></pre><p>Create a model with one OU process per site (unscaled<em>ou</em>params) and one OU process for log(N<em>e).  <code>alpha</code> can be a scalar or a vector of the same length as unscaled</em>ou<em>params. If <code>rescale</code> is true, the nuc</em>matrix is scaled (HB98 neutral scaling).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/57d06a39e2f1978b2332b075dc3fb8522ce88084/src/simulations/ou_hb.jl#L596-L602">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodonMolecularEvolution.ShiftingNeHBSimPartition-Tuple{ShiftingNeHBSimModel}" href="#CodonMolecularEvolution.ShiftingNeHBSimPartition-Tuple{ShiftingNeHBSimModel}"><code>CodonMolecularEvolution.ShiftingNeHBSimPartition</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ShiftingNeHBSimPartition(model; burnin_time)</code></pre><p>Constructs a partition for the <code>ShiftingNeHBSimModel</code>. Initializes by:</p><ul><li>Drawing random unscaled fitnesses from each site&#39;s OU equilibrium.</li><li>Drawing random logNe from its OU equilibrium.</li><li>&quot;Burning in&quot; each site along the branch of length <code>burnin_time</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/57d06a39e2f1978b2332b075dc3fb8522ce88084/src/simulations/ou_hb.jl#L634-L642">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodonMolecularEvolution.difFUBARBaseline" href="#CodonMolecularEvolution.difFUBARBaseline"><code>CodonMolecularEvolution.difFUBARBaseline</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">difFUBARBaseline()</code></pre><p><strong>Description</strong></p><p>Use the trivial implementation of the grid likelihood computations, i.e. 1 thread without sub-tree likelihood caching.</p><p>See also: <code>difFUBARParallel</code>, <code>difFUBARTreesurgery</code>, <code>difFUBARTreesurgeryAndParallel</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/57d06a39e2f1978b2332b075dc3fb8522ce88084/src/difFUBAR/grids.jl#L7-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodonMolecularEvolution.difFUBARParallel" href="#CodonMolecularEvolution.difFUBARParallel"><code>CodonMolecularEvolution.difFUBARParallel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">difFUBARParallel()</code></pre><p><strong>Description</strong></p><p>Extend the baseline version by parallelizing the grid calculations. Requires julia to be launched with the <code>t</code> switch. Using <code>t</code> computational threads, where <code>t</code> is sufficiently small, memory complexity is usually O(t) and time complexity O(1/t). Empirical tests suggests that <code>t</code> should not be higher than the machine&#39;s total CPU threads and usually not higher than half of it&#39;s total threads.</p><p>See also: <code>difFUBARBaseline</code>, <code>difFUBARTreesurgery</code>, <code>difFUBARTreesurgeryAndParallel</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/57d06a39e2f1978b2332b075dc3fb8522ce88084/src/difFUBAR/grids.jl#L17-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodonMolecularEvolution.difFUBARTreesurgery" href="#CodonMolecularEvolution.difFUBARTreesurgery"><code>CodonMolecularEvolution.difFUBARTreesurgery</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">difFUBARTreesurgery()</code></pre><p><strong>Description</strong></p><p>Use sub-tree likelihood caching described in the &quot;Methods&quot; section of the difFUBAR paper. Use more memory than the baseline version but be significantly faster, if purity is high.</p><p>See also: <code>difFUBARBaseline</code>, <code>difFUBARParallel</code>, <code>difFUBARTreesurgeryAndParallel</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/57d06a39e2f1978b2332b075dc3fb8522ce88084/src/difFUBAR/grids.jl#L29-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodonMolecularEvolution.difFUBARTreesurgeryAndParallel" href="#CodonMolecularEvolution.difFUBARTreesurgeryAndParallel"><code>CodonMolecularEvolution.difFUBARTreesurgeryAndParallel</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">difFUBARTreesurgeryAndParallel()</code></pre><p><strong>Description</strong></p><p>Use parallelization and sub-tree likelihood caching. The most performant version in most cases. Use more memory than other versions.</p><p>See also: <code>difFUBARBaseline</code>, <code>difFUBARTreesurgery</code>, <code>difFUBARParallel</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/57d06a39e2f1978b2332b075dc3fb8522ce88084/src/difFUBAR/grids.jl#L41-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodonMolecularEvolution.FUBAR_analysis-Union{Tuple{T}, Tuple{DirichletFUBAR, FUBARGrid{T}}} where T" href="#CodonMolecularEvolution.FUBAR_analysis-Union{Tuple{T}, Tuple{DirichletFUBAR, FUBARGrid{T}}} where T"><code>CodonMolecularEvolution.FUBAR_analysis</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FUBAR_analysis(method::DirichletFUBAR, grid::FUBARGrid{T};
              analysis_name = &quot;dirichlet_fubar_analysis&quot;,
              exports = true,
              posterior_threshold = 0.95,
              verbosity = 1,
              code = MolecularEvolution.universal_code,
              optimize_branch_lengths = false,
              concentration = 0.5,
              iterations = 2500,
              volume_scaling = 1.0) where {T}</code></pre><p>Perform a Fast Unconstrained Bayesian AppRoximation (FUBAR) analysis using a Dirichlet process.</p><p><strong>Arguments</strong></p><ul><li><code>method::DirichletFUBAR</code>: Empty struct to dispatch the original FUBAR method </li><li><code>grid::FUBARGrid{T}</code>: the FUBARGrid to perform inference on</li></ul><p><strong>Keywords</strong></p><ul><li><code>analysis_name::String=&quot;dirichlet_fubar_analysis&quot;</code>: File names</li><li><code>exports::Bool=true</code>: Whether to export results to files. Will plot if MolecularEvolutionViz is present</li><li><code>posterior_threshold::Float64=0.95</code>: Posterior probability classification threshold for </li><li><code>verbosity::Int=1</code>: Control level of output messages (0=none, higher values=more details)</li><li><code>code=MolecularEvolution.universal_code</code>: Molecular code to use</li><li><code>optimize_branch_lengths::Bool=false</code>: ?</li><li><code>concentration::Float64=0.5</code>: Concentration parameter for the Dirichlet process</li><li><code>iterations::Int=2500</code>: Number of EM algorithm iterations</li><li><code>volume_scaling::Float64=1.0</code>: Controls the scaling of the marginal parameter violin plots</li></ul><p><strong>Returns</strong></p><ul><li>A tuple containing:<ul><li><code>df_results</code>: DataFrame with FUBAR analysis results</li><li><code>params</code>: A named tuple with the fields - <code>θ</code>: Parameter estimates from the EM algorithm</li></ul></li></ul><p><strong>Description</strong></p><p>Takes in a FUBARGrid object and outputs results for sites obtained from the FUBAR method </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/57d06a39e2f1978b2332b075dc3fb8522ce88084/src/FUBAR/FUBAR.jl#L175-L211">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodonMolecularEvolution.FUBAR_analysis-Union{Tuple{T}, Tuple{FIFEFUBAR, FUBARGrid{T}}} where T" href="#CodonMolecularEvolution.FUBAR_analysis-Union{Tuple{T}, Tuple{FIFEFUBAR, FUBARGrid{T}}} where T"><code>CodonMolecularEvolution.FUBAR_analysis</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FUBAR_analysis(method::FIFEFUBAR, grid::FUBARGrid{T};
            analysis_name = &quot;fife_analysis&quot;,
            verbosity = 1,
            exports = true,
            positive_tail_only = false) where {T}</code></pre><p>Perform a FUBAR type analysis using the FIFE (Frequentist Inference For Evolution) approach.</p><p><strong>Arguments</strong></p><ul><li><code>method::FIFEFUBAR</code>: Empty struct to dispatch on</li><li><code>grid::FUBARGrid{T}</code>: Grid containing data to perform inference on</li></ul><p><strong>Keywords</strong></p><ul><li><code>analysis_name::String=&quot;fife_analysis&quot;</code>: Name for the analysis output files and directory</li><li><code>verbosity::Int=1</code>: Control level of output messages (0=none, higher values=more details)</li><li><code>exports::Bool=true</code>: Whether to export results to files</li><li><code>positive_tail_only::Bool=false</code>: If true, uses a one-tailed test for positive selection only</li></ul><p><strong>Returns</strong></p><ul><li><code>df_results::DataFrame</code>: A DataFrame containing the frequentist analysis results</li></ul><p><strong>Description</strong></p><p>Frequentist method that gives p-values for site-wise alpha/beta tests</p><p>This function performs likelihood ratio tests at each site using interpolated likelihood surfaces. When <code>positive_tail_only=true</code>, the p-values are adjusted to reflect a one-tailed test that only  considers positive selection (β &gt; α) by using a dirac delta/Chi-square mixture</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/57d06a39e2f1978b2332b075dc3fb8522ce88084/src/FUBAR/FUBAR.jl#L286-L314">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodonMolecularEvolution.FUBAR_analysis-Union{Tuple{T}, Tuple{SKBDIFUBAR, FUBARGrid{T}}} where T" href="#CodonMolecularEvolution.FUBAR_analysis-Union{Tuple{T}, Tuple{SKBDIFUBAR, FUBARGrid{T}}} where T"><code>CodonMolecularEvolution.FUBAR_analysis</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FUBAR_analysis(method::SKBDIFUBAR, grid::FUBARGrid{T};
            analysis_name = &quot;skbdi_fubar_analysis&quot;,
            volume_scaling = 1.0,
            exports = true,
            verbosity = 1,
            posterior_threshold = 0.95,
            distance_function = standard_fubar_distance_function,
            kernel_function = (d, c) -&gt; exp(-d / c^2),
            kernel_parameter_dimension = 1,
            supression_type = nothing,
            m = 15,
            ϵ = 1e-6,
            n_samples = 1000,
            burnin = 200,
            thinning = 50) where {T}</code></pre><p>Perform a Fast Unconstrained Bayesian AppRoximation (FUBAR) analysis using the SKBDI (Smooth Kernel Bayesian Density Inference) approach.</p><p><strong>Arguments</strong></p><ul><li><code>method::SKBDIFUBAR</code>: Empty struct used for dispatch</li><li><code>grid::FUBARGrid{T}</code>: Grid to perform inference on</li></ul><p><strong>Keywords</strong></p><ul><li><code>analysis_name::String=&quot;skbdi_fubar_analysis&quot;</code>: Name for the analysis output files and directory</li><li><code>volume_scaling::Float64=1.0</code>: Controls the scaling of the marginal parameter violin plots</li><li><code>exports::Bool=true</code>: Whether to export results to files</li><li><code>verbosity::Int=1</code>: Control level of output messages (0=none, higher values=more details)</li><li><code>posterior_threshold::Float64=0.95</code>: Posterior probability threshold for classification</li><li><code>distance_function=standard_fubar_distance_function</code>: Function used to calculate distances between grid points</li><li><code>kernel_function=(d, c) -&gt; exp(-d / c^2)</code>: Kernel function used for the covariance matrix. </li><li><code>kernel_parameter_dimension::Int=1</code>: How many kernel parameters are taken in by the kernel bandwidth function. </li><li><code>supression_type=nothing</code>: Supression type object; if nothing, a default supression type is constructed</li><li><code>m::Int=10</code>: Krylov subspace dimension, 15 seems to work well for standard grids. Larger m gives slower sampling but better numerical precision.</li><li><code>ϵ::Float64=1e-6</code>: Tykhonoff regularisation</li><li><code>n_samples::Int=1000</code>: Number of MCMC samples to generate</li><li><code>burnin::Int=200</code>: Number of initial samples to discard as burnin</li><li><code>thinning::Int=50</code>: Interval for thinning samples to reduce autocorrelation</li></ul><p><strong>Returns</strong></p><ul><li>A tuple containing:<ul><li><code>analysis</code>: DataFrame with FUBAR analysis results</li><li><code>params</code>: A named tuple with the fields - <code>θ</code>: Thinned transformed grid samples from the chain, <code>kernel_samples</code>: Samples from the kernel</li></ul></li></ul><p><strong>Description</strong></p><p>This function implements a Smooth Kernel Bayesian Density Inference approach to FUBAR analysis.  It defines a Gaussian model based on the grid, samples from this model using MCMC,  and processes the samples to generate posterior probabilities of selection.</p><p>If no supression type is provided, a default one is constructed based on the grid dimensions with a fifth degree polynomial is used</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/57d06a39e2f1978b2332b075dc3fb8522ce88084/src/FUBAR/gaussianFUBAR.jl#L255-L306">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodonMolecularEvolution.HB98AA_matrix-Tuple{Any, Any, Any}" href="#CodonMolecularEvolution.HB98AA_matrix-Tuple{Any, Any, Any}"><code>CodonMolecularEvolution.HB98AA_matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HB98AA_matrix(alpha, nuc_matrix, AA_fitness; genetic_code = MolecularEvolution.universal_code)</code></pre><p>Returns the rate matrix for a codon model using the HB98 model where each AA has a different fitness. <code>alpha</code> is the synonymous rate, <code>nuc_matrix</code> is the symmetric nucleotide substitution matrix, and <code>AA_fitness</code> is the fitness of each amino acid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/57d06a39e2f1978b2332b075dc3fb8522ce88084/src/simulations/ou_hb.jl#L44-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodonMolecularEvolution.HB98_row-NTuple{4, Any}" href="#CodonMolecularEvolution.HB98_row-NTuple{4, Any}"><code>CodonMolecularEvolution.HB98_row</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HB98AA_row(current_codon, alpha, nuc_matrix, AA_fitness; genetic_code=MolecularEvolution.universal_code)</code></pre><p>Returns the rate row for a codon model using the HB98 model where each AA has a different fitness. <code>current_codon</code> is the current codon, <code>alpha</code> is the synonymous rate, <code>nuc_matrix</code> is the symmetric nucleotide substitution matrix, and <code>AA_fitness</code> is the fitness of each amino acid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/57d06a39e2f1978b2332b075dc3fb8522ce88084/src/simulations/ou_hb.jl#L132-L137">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodonMolecularEvolution.HB_fixation_rate-Tuple{Any, Any}" href="#CodonMolecularEvolution.HB_fixation_rate-Tuple{Any, Any}"><code>CodonMolecularEvolution.HB_fixation_rate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HB_fixation_rate(from_codon, to_codon)

Returns the fixation rate of a mutation from `from_codon` to `to_codon` under the HB98 model.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/57d06a39e2f1978b2332b075dc3fb8522ce88084/src/simulations/ou_hb.jl#L22-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodonMolecularEvolution.HBdNdS-Tuple{Vector{Float64}}" href="#CodonMolecularEvolution.HBdNdS-Tuple{Vector{Float64}}"><code>CodonMolecularEvolution.HBdNdS</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HBdNdS(fs::Vector{Float64}; code = MolecularEvolution.universal_code, nucm = CodonMolecularEvolution.demo_nucmat)
HBdNdS(fs_pre::Vector{Float64}, fs_post::Vector{Float64}; code = MolecularEvolution.universal_code, nucm = CodonMolecularEvolution.demo_nucmat)</code></pre><p>Returns the expected dN/dS ratio for a Halpern and Bruno model with a vector of fitnesses. If two vectors are provided, then the dN/dS ratio is computed for the shift from <code>fs_pre</code> to <code>fs_post</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/57d06a39e2f1978b2332b075dc3fb8522ce88084/src/simulations/ou_hb.jl#L313-L318">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodonMolecularEvolution.HBviz-Tuple{Vector{Float64}, Vector{Vector{Float64}}, Float64, Any, Any}" href="#CodonMolecularEvolution.HBviz-Tuple{Vector{Float64}, Vector{Vector{Float64}}, Float64, Any, Any}"><code>CodonMolecularEvolution.HBviz</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HBviz(ts, fst, T, alp, nucm)</code></pre><p>Visualize over time the fitness trajectory, the codon frequencies, and the expected dN/dS. <code>ts</code> is a vector of times, <code>fst</code> is a vector of fitnesses, <code>T</code> is the total time, <code>alp</code> is the alpha parameter, and <code>nucm</code> is the nucleotide substitution matrix.</p><pre><code class="language-julia hljs">σ = 2.0
alpha = 1.0
nucm = CodonMolecularEvolution.demo_nucmat
fst = [randn(20) .* σ, randn(20) .* σ]
ts = [-100.0, 1.0]
T = 2.0
HBviz(ts, fst, T, alpha, nucm)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/57d06a39e2f1978b2332b075dc3fb8522ce88084/src/simulations/ou_hb.jl#L419-L433">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodonMolecularEvolution.benchmark_global_fit-Tuple{Any}" href="#CodonMolecularEvolution.benchmark_global_fit-Tuple{Any}"><code>CodonMolecularEvolution.benchmark_global_fit</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CodonMolecularEvolution.benchmark_global_fit(benchmark_name; exports=true, data=1:5, optimize_branch_lengths=false)</code></pre><p>Benchmarks different implementations of the difFUBAR<em>global</em>fit algorithm. Results of the benchmark are printed out as a DataFrame and saved to a CSV file.  Uses the heuristic top pick to generate con lik matrices. Compares difference in con lik matrices. If exports is true, it also runs MCMCs on the con lik matrices and plots the means and posteriors of the different versions.</p><ul><li><code>benchmark_name</code> is the filepath to where the benchmark will be saved, if exports.</li><li><code>data</code> is the range/vector of datasets to run the benchmark on. By default, this is 1:5. These are the enumerated datasets:<ul><li><ol><li>Ace2nobackground</li></ol></li><li><ol><li>Ace2reallytiny</li></ol></li><li><ol><li>Ace2tiny</li></ol></li><li><ol><li>ParvoVP</li></ol></li><li><ol><li>ParvoVPregrouped</li></ol></li></ul></li><li><code>optimize_branch_lengths</code> is an option that can be either <code>true</code>, <code>false</code> or <code>&quot;detect&quot;</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/57d06a39e2f1978b2332b075dc3fb8522ce88084/test/benchmark_difFUBAR.jl#L229-L242">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodonMolecularEvolution.benchmark_grid-Tuple{Any}" href="#CodonMolecularEvolution.benchmark_grid-Tuple{Any}"><code>CodonMolecularEvolution.benchmark_grid</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CodonMolecularEvolution.benchmark_grid(benchmark_name; exports=true, versions_option=1, t::Integer=0, data=1:5)</code></pre><p>Benchmarks different implementations of the difFUBAR_grid algorithm. Results of the benchmark are printed out as a DataFrame and saved to a CSV file.</p><ul><li><code>benchmark_name</code> is the filepath to where the benchmark will be saved, if exports</li><li><code>versions_option</code> have 4 different options:<ul><li><ol><li>default option, only run heuristic top pick</li></ol></li><li><ol><li>only run baseline version</li></ol></li><li><ol><li>run heuristic top pick and baseline version</li></ol></li><li><ol><li>run all versions</li></ol></li></ul></li><li><code>t</code> is the number of threads you want to use in the parallel versions. If specified and non-zero, this will override the number of threads chosen by the heuristic.</li><li><code>data</code> is the range/vector of datasets to run the benchmark on. By default, this is 1:5. These are the enumerated datasets:<ul><li><ol><li>Ace2nobackground</li></ol></li><li><ol><li>Ace2reallytiny</li></ol></li><li><ol><li>Ace2tiny</li></ol></li><li><ol><li>ParvoVP</li></ol></li><li><ol><li>ParvoVPregrouped</li></ol></li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/57d06a39e2f1978b2332b075dc3fb8522ce88084/test/benchmark_difFUBAR.jl#L169-L185">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodonMolecularEvolution.dNdS-Tuple{Any, Any, Vector{Float64}}" href="#CodonMolecularEvolution.dNdS-Tuple{Any, Any, Vector{Float64}}"><code>CodonMolecularEvolution.dNdS</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dNdS(q1, q0, p; code = MolecularEvolution.universal_code)
dNdS(q1, q0; code = MolecularEvolution.universal_code)</code></pre><p>Returns an analytic expectation of the dN/dS ratio for a codon model. <code>q1</code> is the rate matrix where selection is active (eg. a Halpern and Bruno model with a set of fitnesses), and <code>q0</code> is the corresponding rate matrix where selection is inactive (eg. a Halpern and Bruno model with all fitnesses equal). <code>p</code> is the frequency distribution over codons that the dN/dS ratio is computed against. If not provided, this is computed as the equilibrium from <code>q1</code>. If only a vector of fitnesses are provided, then the <code>q1</code>, <code>q0</code>, and <code>p</code> are computed assuming a Halpern and Bruno model.</p><pre><code class="nohighlight hljs">fs = randn(20)
nucm = CodonMolecularEvolution.demo_nucmat
q1 = HB98AA_matrix(1.0, nucm, fs)
q0 = HB98AA_matrix(1.0, nucm, zeros(20))
dNdS(q1, q0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/57d06a39e2f1978b2332b075dc3fb8522ce88084/src/simulations/ou_hb.jl#L283-L298">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodonMolecularEvolution.difFUBAR-NTuple{5, Any}" href="#CodonMolecularEvolution.difFUBAR-NTuple{5, Any}"><code>CodonMolecularEvolution.difFUBAR</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">difFUBAR(seqnames, seqs, treestring, tags, outpath; &lt;keyword arguments&gt;)</code></pre><p>Takes a tagged phylogeny and an alignment as input and performs difFUBAR analysis. Returns <code>df, results_tuple, plots_named_tuple</code> where <code>df</code> is a DataFrame of the detected sites, <code>results_tuple</code> is a tuple of the partial calculations needed to re-run <code>difFUBAR_tabulate_and_plot</code>, and <code>plots_named_tuple</code> is a named tuple of plots. Consistent with the docs of <a href="#CodonMolecularEvolution.difFUBAR_tabulate_and_plot-NTuple{7, Any}"><code>difFUBAR_tabulate_and_plot</code></a>, <code>results_tuple</code> stores <code>(alloc_grid, codon_param_vec, alphagrid, omegagrid, tag_colors)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>seqnames</code>: vector of untagged sequence names.</li><li><code>seqs</code>: vector of aligned sequences, corresponding to <code>seqnames</code>.</li><li><code>treestring</code>: a tagged newick tree string.</li><li><code>tags</code>: vector of tag signatures.</li><li><code>outpath</code>: export directory.</li><li><code>tag_colors=DIFFUBAR_TAG_COLORS[sortperm(tags)]</code>: vector of tag colors (hex format). The default option is consistent with the difFUBAR paper (Foreground 1: red, Foreground 2: blue).</li><li><code>pos_thresh=0.95</code>: threshold of significance for the posteriors.</li><li><code>iters=2500</code>: iterations used in the Gibbs sampler.</li><li><code>binarize=false</code>: if true, the tree is binarized before the analysis.</li><li><code>verbosity=1</code>: as verbosity increases, prints are added accumulatively. <ul><li>0 - no prints</li><li>1 - show current step and where output files are exported</li><li>2 - show the chosen <code>difFUBAR_grid</code> version and amount of parallel threads.</li></ul></li><li><code>exports=true</code>: if true, output files are exported.</li><li><code>code=MolecularEvolution.universal_code</code>: genetic code used for the analysis.</li><li><code>optimize_branch_lengths=false</code>: if true, the branch lengths of the phylogenetic tree are optimized.</li><li><code>version::Union{difFUBARGrid, Nothing}=nothing</code>: explicitly choose the version of <code>difFUBAR_grid</code> to use. If <code>nothing</code>, the version is heuristically chosen based on the available RAM and Julia threads.</li><li><code>t=0</code>: explicitly choose the amount of Julia threads to use. If <code>0</code>, the degree of parallelization is heuristically chosen based on the available RAM and Julia threads.</li></ul><div class="admonition is-info" id="Note-b03068c57dce8771"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-b03068c57dce8771" title="Permalink"></a></header><div class="admonition-body"><p>Julia starts up with a single thread of execution, by default. See <a href="https://docs.julialang.org/en/v1/manual/multi-threading/#Starting-Julia-with-multiple-threads">Starting Julia with multiple threads</a>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/57d06a39e2f1978b2332b075dc3fb8522ce88084/src/difFUBAR/difFUBAR.jl#L278-L307">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodonMolecularEvolution.difFUBAR_init-Tuple{Any, Any, Any}" href="#CodonMolecularEvolution.difFUBAR_init-Tuple{Any, Any, Any}"><code>CodonMolecularEvolution.difFUBAR_init</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/57d06a39e2f1978b2332b075dc3fb8522ce88084/src/difFUBAR/difFUBAR.jl#L38-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodonMolecularEvolution.difFUBAR_tabulate_and_plot-NTuple{7, Any}" href="#CodonMolecularEvolution.difFUBAR_tabulate_and_plot-NTuple{7, Any}"><code>CodonMolecularEvolution.difFUBAR_tabulate_and_plot</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">difFUBAR_tabulate_and_plot(analysis_name, pos_thresh, alloc_grid, codon_param_vec, alphagrid, omegagrid, tag_colors, verbosity=1, exports=true)</code></pre><p>Takes the output of <code>difFUBAR</code>, tabulates and plots the results. Returns a DataFrame of tabulated results, a tuple of partial calculations needed to re-run tabulate, and a vector of plots. This function enables you to use the results of <code>difFUBAR</code> to tabulate the results with a different threshold.</p><p><strong>Arguments</strong></p><ul><li><code>analysis_name</code>: where to export the results.</li><li><code>pos_thresh</code>: threshold of significance for the posteriors.</li><li><code>alloc_grid</code>: contains the result of the Gibbs sampler.</li><li><code>codon_param_vec</code>: vector of codon parameters from difFUBAR.</li><li><code>alphagrid</code>: grid of alpha values.</li><li><code>omegagrid</code>: grid of omega values.</li><li><code>tag_colors</code>: colors of the tags.</li><li><code>verbosity=1</code>: will print to stdout if 1, will not print to stdout if 0.</li><li><code>exports=true</code>: if true, output files are exported.</li></ul><p>If:</p><pre><code class="language-julia hljs">df, results, plots = difFUBAR(seqnames, seqs, treestring, tags, &quot;my_analysis&quot;)</code></pre><p>Then you can retabulate and replot by propagating the <code>results</code> tuple:</p><pre><code class="language-julia hljs">difFUBAR_tabulate_and_plot(&quot;my_analysis_0.85&quot;, 0.85, results...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/57d06a39e2f1978b2332b075dc3fb8522ce88084/src/difFUBAR/difFUBAR.jl#L229-L256">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodonMolecularEvolution.generate_ambient_indices-Tuple{Int64}" href="#CodonMolecularEvolution.generate_ambient_indices-Tuple{Int64}"><code>CodonMolecularEvolution.generate_ambient_indices</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_ambient_indices(N::Int)</code></pre><p>Generate ambient format indices for an NxN grid. Indices are generated along diagonals from bottom-right to top-left, with each diagonal numbered from bottom to top.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/57d06a39e2f1978b2332b075dc3fb8522ce88084/src/FUBAR/grid_utilities.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodonMolecularEvolution.generate_fubar_indices-Tuple{Int64}" href="#CodonMolecularEvolution.generate_fubar_indices-Tuple{Int64}"><code>CodonMolecularEvolution.generate_fubar_indices</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_fubar_indices(N::Int)</code></pre><p>Generate FUBAR format indices for an NxN grid. Indices are generated column-wise from bottom to top, starting from the leftmost column.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/57d06a39e2f1978b2332b075dc3fb8522ce88084/src/FUBAR/grid_utilities.jl#L31-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodonMolecularEvolution.getpuresubclades-Tuple{MolecularEvolution.FelNode, Vector{String}}" href="#CodonMolecularEvolution.getpuresubclades-Tuple{MolecularEvolution.FelNode, Vector{String}}"><code>CodonMolecularEvolution.getpuresubclades</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getpuresubclades(tree::FelNode, tags::Vector{String})</code></pre><ul><li>Should usually be called on the root of the tree. Traverses the tree iteratively with a depth-first search to find roots of pure subclades, presuming that nodenames have been trailed with tags. Returns a Vector{FelNode} with root-nodes of the pure subclades.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/57d06a39e2f1978b2332b075dc3fb8522ce88084/src/difFUBAR/grids.jl#L92-L96">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodonMolecularEvolution.import_colored_figtree_nexus_as_tagged_tree-Tuple{Any}" href="#CodonMolecularEvolution.import_colored_figtree_nexus_as_tagged_tree-Tuple{Any}"><code>CodonMolecularEvolution.import_colored_figtree_nexus_as_tagged_tree</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">import_colored_figtree_nexus_as_tagged_tree(fname; custom_labels=String[])</code></pre><p>Takes a nexus file from FigTree, where branches have been colored. Replaces all color tags with group tags that can be used in the models. Can add custom labels too. Should consider an entire custom dictionary as well in future.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; treestring, tags, tag_colors = import_colored_figtree_nexus_as_tagged_tree(&quot;data/Ace2_no_background.nex&quot;)
(&quot;(((XM_027533928_Bos_indicus_x_Bos_taurus{G1}:0.097072,(XM_042974087_Panthera_tigris{G1}:0.038016,... more ...;&quot;, [&quot;{G2}&quot;, &quot;{G1}&quot;], [&quot;#ff0015&quot;, &quot;#0011ff&quot;])</code></pre><div class="admonition is-info" id="Note-3aad5efe2df275e9"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-3aad5efe2df275e9" title="Permalink"></a></header><div class="admonition-body"><p><code>treestring</code> is truncated. <a href="https://raw.githubusercontent.com/MurrellGroup/CodonMolecularEvolution.jl/main/test/data/Ace2_no_background/Ace2_no_background.nex">NEXUS tree file</a></p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/57d06a39e2f1978b2332b075dc3fb8522ce88084/src/shared/shared.jl#L14-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodonMolecularEvolution.import_grouped_label_tree-Tuple{Any}" href="#CodonMolecularEvolution.import_grouped_label_tree-Tuple{Any}"><code>CodonMolecularEvolution.import_grouped_label_tree</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">import_grouped_label_tree(tree_file)</code></pre><p>Takes a Newick tree file and return Newick tree, Newick tree with replaced tags, group tags, original tags, and randomly generated colours for each tag</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/57d06a39e2f1978b2332b075dc3fb8522ce88084/src/shared/shared.jl#L150-L154">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodonMolecularEvolution.import_labeled_phylotree_newick-Tuple{Any}" href="#CodonMolecularEvolution.import_labeled_phylotree_newick-Tuple{Any}"><code>CodonMolecularEvolution.import_labeled_phylotree_newick</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">import_labeled_phylotree_newick(fname)</code></pre><p>Import a tagged phylogeny from phylotree and return the treestring and tags.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/57d06a39e2f1978b2332b075dc3fb8522ce88084/src/shared/shared.jl#L186-L190">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodonMolecularEvolution.jump-Tuple{Any, Any, PiecewiseOUModel}" href="#CodonMolecularEvolution.jump-Tuple{Any, Any, PiecewiseOUModel}"><code>CodonMolecularEvolution.jump</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">jump(x_source, m::PiecewiseOUModel)</code></pre><p>Evolves values over time using a piecewise constant approximation to an OU process, where this function computes the new distribution for a single discrete jump. <code>x_source</code> is the vector of fitnesses, and m is the PiecewiseOUModel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/57d06a39e2f1978b2332b075dc3fb8522ce88084/src/simulations/ou_hb.jl#L113-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodonMolecularEvolution.jumpy_HB_codon_evolve-NTuple{6, Any}" href="#CodonMolecularEvolution.jumpy_HB_codon_evolve-NTuple{6, Any}"><code>CodonMolecularEvolution.jumpy_HB_codon_evolve</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">jumpy_HB_codon_evolve(fitnesses, codon, ou_model, nuc_matrix, alpha, time;
    genetic_code = MolecularEvolution.universal_code, push_into = nothing)</code></pre><p>Evolves fitnesses and codons over time using the HB98 model. <code>fitnesses</code> is the vector of fitnesses, <code>codon</code> is the current codon, <code>ou_model</code> is the OU model, <code>nuc_matrix</code> is the symmetric nucleotide substitution matrix, <code>alpha</code> is the synonymous rate, and <code>time</code> is the total time to evolve over.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/57d06a39e2f1978b2332b075dc3fb8522ce88084/src/simulations/ou_hb.jl#L162-L168">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodonMolecularEvolution.jumpy_NeHB_codon_evolve-NTuple{6, Any}" href="#CodonMolecularEvolution.jumpy_NeHB_codon_evolve-NTuple{6, Any}"><code>CodonMolecularEvolution.jumpy_NeHB_codon_evolve</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">jumpy_NeHB_codon_evolve(fitnesses, logNe_trajectory, codon, fitness_model, nuc_matrix, alpha;
genetic_code = MolecularEvolution.universal_code, push_into = nothing)</code></pre><p>Evolves codons and unscaled site-fitness, along with a given trajectory of log-pop-size.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/57d06a39e2f1978b2332b075dc3fb8522ce88084/src/simulations/ou_hb.jl#L518-L523">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodonMolecularEvolution.maxdNdS2std-Tuple{Any}" href="#CodonMolecularEvolution.maxdNdS2std-Tuple{Any}"><code>CodonMolecularEvolution.maxdNdS2std</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">maxdNdS2std(ω)</code></pre><p>Inverse of std2maxdNdS(σ). Estimates the standard deviation of the fitnesses that will produce, in expectation, a dN/dS ratio of <code>ω</code>, assuming Gaussian fitnesses and a Halpern and Bruno model, where the fitnesses have just shifted from one Gaussian sample to another. Note: this is not an analytical solution, but a serindipitously good approximation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/57d06a39e2f1978b2332b075dc3fb8522ce88084/src/simulations/ou_hb.jl#L350-L355">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodonMolecularEvolution.optimize_MG94_F3x4-Tuple{Any, Any, Any}" href="#CodonMolecularEvolution.optimize_MG94_F3x4-Tuple{Any, Any, Any}"><code>CodonMolecularEvolution.optimize_MG94_F3x4</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">optimize_MG94_F3x4(seqnames, seqs, tree; leaf_name_transform=x -&gt; x, genetic_code=MolecularEvolution.universal_code)</code></pre><p>Optimizes the MG94+F3x4 model on a tree, given a set of sequences and a tree. Returns the optimized tree, alpha, beta, nuc<em>matrix, F3x4, and eq</em>freqs. The leaf<em>name</em>transform kwarg can be used to transform the leaf names in the tree to match the seqnames.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/57d06a39e2f1978b2332b075dc3fb8522ce88084/src/shared/shared.jl#L201-L206">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodonMolecularEvolution.shiftingHBviz-NTuple{6, Any}" href="#CodonMolecularEvolution.shiftingHBviz-NTuple{6, Any}"><code>CodonMolecularEvolution.shiftingHBviz</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">shiftingHBviz(T, event_rate, σ, mixing_rate, alpha, nucm; T0 = -20)</code></pre><p>Visualize the fitness trajectory, codon frequencies, and expected dN/dS over time for a shifting HB process. <code>T</code> is the total time, <code>event_rate</code> is the rate of fitness shifts, <code>σ</code> is the standard deviation of the fitnesses, <code>mixing_rate</code> is the rate of mixing between fitnesses, <code>alpha</code> is the alpha parameter, and <code>nucm</code> is the nucleotide substitution matrix. <code>T0</code> controls the burnin time, to ensure the process is at equilibrium at <code>t=0</code>.</p><pre><code class="language-julia hljs">T = 2.0
mix = 1.0
σ = 5.0
event_rate = 100.0
alpha = 1.0
nucm = CodonMolecularEvolution.demo_nucmat
shiftingHBviz(T, event_rate, σ, mix, alpha, nucm)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/57d06a39e2f1978b2332b075dc3fb8522ce88084/src/simulations/ou_hb.jl#L477-L494">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodonMolecularEvolution.shiftingNeHBviz-NTuple{10, Any}" href="#CodonMolecularEvolution.shiftingNeHBviz-NTuple{10, Any}"><code>CodonMolecularEvolution.shiftingNeHBviz</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">shiftingNeHBviz(T, f_event_rate, f_σ, f_mixing_rate, logNe_event_rate, logNe_σ, logNe_mean, logNe_mixing_rate, alpha, nucm; T0 = -20)</code></pre><p>Visualize the Ne trajectory, fitness trajectory, codon frequencies, and expected dN/dS over time for a shifting Ne HB process.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/57d06a39e2f1978b2332b075dc3fb8522ce88084/src/simulations/ou_hb.jl#L561-L565">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodonMolecularEvolution.sim_alphabeta_seqs-Tuple{Vector{Float64}, Vector{Float64}, Any, Matrix{Float64}, Matrix{Float64}}" href="#CodonMolecularEvolution.sim_alphabeta_seqs-Tuple{Vector{Float64}, Vector{Float64}, Any, Matrix{Float64}, Matrix{Float64}}"><code>CodonMolecularEvolution.sim_alphabeta_seqs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sim_alphabeta_seqs(alphavec::Vector{Float64}, betavec::Vector{Float64}, singletree, nucmat::Array{Float64,2}, f3x4::Array{Float64,2};
                        scale_total_tree_neutral_expected_subs = -1.0, outpath = &quot;&quot;)</code></pre><p>Simulate a set of sequences under a given tree, with a set of alpha and beta values. f3x4 is a 3-by-4 matrix of position-specific nucleotide frequencies. nucmat is a 4-by-4 matrix of nucleotide substitution rates. If scale<em>total</em>tree<em>neutral</em>expected<em>subs &gt; 0, then the tree is scaled so that if alpha=beta=1 for all sites, the expected number of neutral substitutions is equal to scale</em>total<em>tree</em>neutral<em>expected</em>subs. The sequences are written to a fasta file, and the tree is written to a newick file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/57d06a39e2f1978b2332b075dc3fb8522ce88084/src/simulations/alphabeta/alphabeta.jl#L23-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodonMolecularEvolution.std2maxdNdS-Tuple{Any}" href="#CodonMolecularEvolution.std2maxdNdS-Tuple{Any}"><code>CodonMolecularEvolution.std2maxdNdS</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">std2maxdNdS(σ)</code></pre><p>Approximation for the maximum dN/dS ratio as a function of the standard deviation of the fitnesses, assuming Gaussian fitnesses and a Halpern and Bruno model, where the fitnesses have just shifted from one Gaussian sample to another. Note: this is not an analytical solution, but a serindipitously good approximation.</p><pre><code class="nohighlight hljs">function monte_carlo_maxdNdS(σ; N=100_000)
    sum_val = 0.0
    for _ in 1:N
        f_i = σ * randn()
        f_j = σ * randn()
        sum_val += HB_fixation_rate(f_i, f_j)
    end
    return sum_val / N
end
vs = 0:0.01:10
plot(vs, monte_carlo_maxdNdS.(vs), label = &quot;Monte Carlo&quot;, alpha = 0.8)
plot!(vs, std2maxdNdS.(vs), label = &quot;Approx&quot;, linestyle = :dash, alpha = 0.8)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/57d06a39e2f1978b2332b075dc3fb8522ce88084/src/simulations/ou_hb.jl#L327-L347">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodonMolecularEvolution.time_varying_HB_freqs-NTuple{4, Any}" href="#CodonMolecularEvolution.time_varying_HB_freqs-NTuple{4, Any}"><code>CodonMolecularEvolution.time_varying_HB_freqs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">time_varying_HB_freqs(ts, T, fst, init_freqs; nucm = CodonMolecularEvolution.demo_nucmat, alpha = 1.0, delta_t = 0.002, prezero_delta_t = 0.5)</code></pre><p>Compute the time-varying codon frequencies and expected dN/dS over time for a sequence of fitnesses, under the Halpern-Bruno model. <code>ts</code> is a vector of times, <code>T</code> is the total time, <code>fst</code> is a vector of vector of fitnesses, <code>init_freqs</code> is the initial codon frequencies, <code>nucm</code> is the nucleotide substitution matrix, <code>alpha</code> is the alpha parameter, <code>delta_t</code> is the discretization time step for the simulation, and <code>prezero_delta_t</code> is the time step used before <code>t=0</code>. <code>fst[i]</code> is assumed to be the fitness between <code>t = ts[i]</code> and <code>t = ts[i+1]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/57d06a39e2f1978b2332b075dc3fb8522ce88084/src/simulations/ou_hb.jl#L358-L365">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MolecularEvolution.forward!-Tuple{ShiftingNeHBSimPartition, ShiftingNeHBSimPartition, ShiftingNeHBSimModel, MolecularEvolution.FelNode}" href="#MolecularEvolution.forward!-Tuple{ShiftingNeHBSimPartition, ShiftingNeHBSimPartition, ShiftingNeHBSimModel, MolecularEvolution.FelNode}"><code>MolecularEvolution.forward!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">forward!(dest, source, model, node)</code></pre><p>Evolves <code>source</code> partition along <code>node.branchlength</code> under <code>model</code>, storing the result in <code>dest</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/57d06a39e2f1978b2332b075dc3fb8522ce88084/src/simulations/ou_hb.jl#L696-L700">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="difFUBAR/">difFUBAR »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.0 on <span class="colophon-date" title="Saturday 10 May 2025 23:21">Saturday 10 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

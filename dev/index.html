<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · CodonMolecularEvolution.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://MurrellGroup.github.io/CodonMolecularEvolution.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href><img src="assets/logo.png" alt="CodonMolecularEvolution.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href>CodonMolecularEvolution.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li><li><a class="tocitem" href="difFUBAR/">difFUBAR</a></li><li><a class="tocitem" href="shared/">Shared tools</a></li><li><a class="tocitem" href="dataprep/">Data preparation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/main/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="CodonMolecularEvolution"><a class="docs-heading-anchor" href="#CodonMolecularEvolution">CodonMolecularEvolution</a><a id="CodonMolecularEvolution-1"></a><a class="docs-heading-anchor-permalink" href="#CodonMolecularEvolution" title="Permalink"></a></h1><h3 id="A-Julia-package-for-popular-and-new-codon-models-of-molecular-evolution."><a class="docs-heading-anchor" href="#A-Julia-package-for-popular-and-new-codon-models-of-molecular-evolution.">A Julia package for popular and new codon models of molecular evolution.</a><a id="A-Julia-package-for-popular-and-new-codon-models-of-molecular-evolution.-1"></a><a class="docs-heading-anchor-permalink" href="#A-Julia-package-for-popular-and-new-codon-models-of-molecular-evolution." title="Permalink"></a></h3><p>Documentation for <a href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl">CodonMolecularEvolution</a>.</p><p>Descendant of <a href="https://github.com/MurrellGroup/MolecularEvolution.jl">MolecularEvolution.jl</a>, specializing in codon models.</p><h3 id="Collection-of-codon-model-methods"><a class="docs-heading-anchor" href="#Collection-of-codon-model-methods">Collection of codon model methods</a><a id="Collection-of-codon-model-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Collection-of-codon-model-methods" title="Permalink"></a></h3><ul><li><a href="difFUBAR/#difFUBAR">difFUBAR</a>: Scalable Bayesian comparison of selection pressure<ul><li>Perform a site-wise comparison of evolutionary pressure between two selected sets of branches.</li><li>Authors: Hassan Sadiq, Venkatesh Kumar, and Ben Murrell (original model development), Patrick Truong (benchmarking), Maximilian Danielsson (performance optimization).</li></ul></li></ul><h3 id="Design-principles"><a class="docs-heading-anchor" href="#Design-principles">Design principles</a><a id="Design-principles-1"></a><a class="docs-heading-anchor-permalink" href="#Design-principles" title="Permalink"></a></h3><ul><li>User-facing<ul><li>Users with no Julia experience should be able to run these models.</li></ul></li><li>Scalability<ul><li>Models should scale to large, real-world datasets. To keep the memory footprint down, we use <code>MolecularEvolution.jl</code>s <code>LazyPartition</code> when possible.</li></ul></li><li>Performance<ul><li>We try to maintain competitive runtimes by using e.g. computational shortcuts and parallelization whenever we can.</li></ul></li></ul><h3 id="Package-Authors-and-Maintainers"><a class="docs-heading-anchor" href="#Package-Authors-and-Maintainers">Package Authors and Maintainers</a><a id="Package-Authors-and-Maintainers-1"></a><a class="docs-heading-anchor-permalink" href="#Package-Authors-and-Maintainers" title="Permalink"></a></h3><p>Maximilian Danielsson and Ben Murrell. Authors for specific models listed above.</p><ul><li><a href="#CodonMolecularEvolution.PiecewiseOUModel"><code>CodonMolecularEvolution.PiecewiseOUModel</code></a></li><li><a href="#CodonMolecularEvolution.ShiftingHBSimModel"><code>CodonMolecularEvolution.ShiftingHBSimModel</code></a></li><li><a href="#CodonMolecularEvolution.ShiftingHBSimPartition"><code>CodonMolecularEvolution.ShiftingHBSimPartition</code></a></li><li><a href="#CodonMolecularEvolution.ShiftingNeHBSimModel-Union{Tuple{C}, Tuple{B}, Tuple{A}, Tuple{Matrix{Float64}, Array{PiecewiseOUModel{A, B, C}, 1}, PiecewiseOUModel}} where {A, B, C}"><code>CodonMolecularEvolution.ShiftingNeHBSimModel</code></a></li><li><a href="#CodonMolecularEvolution.ShiftingNeHBSimPartition-Tuple{ShiftingNeHBSimModel}"><code>CodonMolecularEvolution.ShiftingNeHBSimPartition</code></a></li><li><a href="difFUBAR/#CodonMolecularEvolution.difFUBARBaseline"><code>CodonMolecularEvolution.difFUBARBaseline</code></a></li><li><a href="difFUBAR/#CodonMolecularEvolution.difFUBARParallel"><code>CodonMolecularEvolution.difFUBARParallel</code></a></li><li><a href="difFUBAR/#CodonMolecularEvolution.difFUBARTreesurgery"><code>CodonMolecularEvolution.difFUBARTreesurgery</code></a></li><li><a href="difFUBAR/#CodonMolecularEvolution.difFUBARTreesurgeryAndParallel"><code>CodonMolecularEvolution.difFUBARTreesurgeryAndParallel</code></a></li><li><a href="#CodonMolecularEvolution.HB98AA_matrix-Tuple{Any, Any, Any}"><code>CodonMolecularEvolution.HB98AA_matrix</code></a></li><li><a href="#CodonMolecularEvolution.HB98_row-NTuple{4, Any}"><code>CodonMolecularEvolution.HB98_row</code></a></li><li><a href="#CodonMolecularEvolution.HB_fixation_rate-Tuple{Any, Any}"><code>CodonMolecularEvolution.HB_fixation_rate</code></a></li><li><a href="#CodonMolecularEvolution.HBdNdS-Tuple{Vector{Float64}}"><code>CodonMolecularEvolution.HBdNdS</code></a></li><li><a href="#CodonMolecularEvolution.HBviz-Tuple{Vector{Float64}, Vector{Vector{Float64}}, Float64, Any, Any}"><code>CodonMolecularEvolution.HBviz</code></a></li><li><a href="#CodonMolecularEvolution.benchmark_global_fit-Tuple{Any}"><code>CodonMolecularEvolution.benchmark_global_fit</code></a></li><li><a href="#CodonMolecularEvolution.benchmark_grid-Tuple{Any}"><code>CodonMolecularEvolution.benchmark_grid</code></a></li><li><a href="#CodonMolecularEvolution.dNdS-Tuple{Any, Any, Vector{Float64}}"><code>CodonMolecularEvolution.dNdS</code></a></li><li><a href="#CodonMolecularEvolution.difFUBAR-NTuple{5, Any}"><code>CodonMolecularEvolution.difFUBAR</code></a></li><li><a href="difFUBAR/#CodonMolecularEvolution.difFUBAR"><code>CodonMolecularEvolution.difFUBAR</code></a></li><li><a href="#CodonMolecularEvolution.difFUBAR_init-Tuple{Any, Any, Any}"><code>CodonMolecularEvolution.difFUBAR_init</code></a></li><li><a href="#CodonMolecularEvolution.difFUBAR_tabulate-NTuple{6, Any}"><code>CodonMolecularEvolution.difFUBAR_tabulate</code></a></li><li><a href="#CodonMolecularEvolution.getpuresubclades-Tuple{MolecularEvolution.FelNode, Vector{String}}"><code>CodonMolecularEvolution.getpuresubclades</code></a></li><li><a href="#CodonMolecularEvolution.import_colored_figtree_nexus_as_tagged_tree-Tuple{Any}"><code>CodonMolecularEvolution.import_colored_figtree_nexus_as_tagged_tree</code></a></li><li><a href="shared/#CodonMolecularEvolution.import_colored_figtree_nexus_as_tagged_tree"><code>CodonMolecularEvolution.import_colored_figtree_nexus_as_tagged_tree</code></a></li><li><a href="#CodonMolecularEvolution.import_grouped_label_tree-Tuple{Any}"><code>CodonMolecularEvolution.import_grouped_label_tree</code></a></li><li><a href="shared/#CodonMolecularEvolution.import_grouped_label_tree"><code>CodonMolecularEvolution.import_grouped_label_tree</code></a></li><li><a href="#CodonMolecularEvolution.import_labeled_phylotree_newick-Tuple{Any}"><code>CodonMolecularEvolution.import_labeled_phylotree_newick</code></a></li><li><a href="shared/#CodonMolecularEvolution.import_labeled_phylotree_newick"><code>CodonMolecularEvolution.import_labeled_phylotree_newick</code></a></li><li><a href="#CodonMolecularEvolution.jump-Tuple{Any, Any, PiecewiseOUModel}"><code>CodonMolecularEvolution.jump</code></a></li><li><a href="#CodonMolecularEvolution.jumpy_HB_codon_evolve-NTuple{6, Any}"><code>CodonMolecularEvolution.jumpy_HB_codon_evolve</code></a></li><li><a href="#CodonMolecularEvolution.jumpy_NeHB_codon_evolve-NTuple{6, Any}"><code>CodonMolecularEvolution.jumpy_NeHB_codon_evolve</code></a></li><li><a href="#CodonMolecularEvolution.maxdNdS2std-Tuple{Any}"><code>CodonMolecularEvolution.maxdNdS2std</code></a></li><li><a href="shared/#CodonMolecularEvolution.optimize_MG94_F3x4"><code>CodonMolecularEvolution.optimize_MG94_F3x4</code></a></li><li><a href="#CodonMolecularEvolution.optimize_MG94_F3x4-Tuple{Any, Any, Any}"><code>CodonMolecularEvolution.optimize_MG94_F3x4</code></a></li><li><a href="#CodonMolecularEvolution.shiftingHBviz-NTuple{6, Any}"><code>CodonMolecularEvolution.shiftingHBviz</code></a></li><li><a href="#CodonMolecularEvolution.shiftingNeHBviz-NTuple{10, Any}"><code>CodonMolecularEvolution.shiftingNeHBviz</code></a></li><li><a href="#CodonMolecularEvolution.sim_alphabeta_seqs-Tuple{Vector{Float64}, Vector{Float64}, Any, Matrix{Float64}, Matrix{Float64}}"><code>CodonMolecularEvolution.sim_alphabeta_seqs</code></a></li><li><a href="#CodonMolecularEvolution.std2maxdNdS-Tuple{Any}"><code>CodonMolecularEvolution.std2maxdNdS</code></a></li><li><a href="#CodonMolecularEvolution.time_varying_HB_freqs-NTuple{4, Any}"><code>CodonMolecularEvolution.time_varying_HB_freqs</code></a></li><li><a href="#MolecularEvolution.forward!-Tuple{ShiftingNeHBSimPartition, ShiftingNeHBSimPartition, ShiftingNeHBSimModel, MolecularEvolution.FelNode}"><code>MolecularEvolution.forward!</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="CodonMolecularEvolution.PiecewiseOUModel" href="#CodonMolecularEvolution.PiecewiseOUModel"><code>CodonMolecularEvolution.PiecewiseOUModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PiecewiseOUModel(event_rate::Float64, eq_std::Float64, mixing::Float64; delta_t = 1.0)
PiecewiseOUModel(offsets::Vector{Float64})
PiecewiseOUModel(event_rate::Float64, eq_std::Float64, mixing::Float64, mu::Union{Float64,Vector{Float64}}, offsets::Union{Float64,Vector{Float64}}, codon_offsets::Union{Float64,Vector{Float64}})</code></pre><p>A piecewise constant approximation to an OU process, intended to simulate fitnesses evolving over phylogenies. The equilibrium standard deviation is directly parameterized (<code>eq_std</code>), as is the rate at which the process mixes to equilibrium (<code>mixing</code>). <code>event_rate</code> controls how often the fitness changes occur, where the mixing rate is scaled to compensate for the increased rate of change to achieve approximately the same amount of change per unit time even as the <code>event_rate</code> changes. A very high <code>event_rate</code> will behave more like continuous diffusion, but will be more computationally expensive to sample from. <code>mu</code> can also be set to control the mean fitnesses. The model also permits <code>offsets</code>, which are added to the fitnesses as they are passed into the model. For a single process, these are confounded with the mean <code>mu</code> but if the offsets change (eg. from one branch to another) the effective fitnesses will immidiately change, whereas if <code>mu</code> changes the fitnesses will drift towards <code>mu</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/aebfdeedd90dd2754e3150178c09e039547f3106/src/simulations/ou_hb.jl#L79-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodonMolecularEvolution.ShiftingHBSimModel" href="#CodonMolecularEvolution.ShiftingHBSimModel"><code>CodonMolecularEvolution.ShiftingHBSimModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ShiftingHBSimModel(sites, alphas, ou_params, nuc_matrix; rescale = true)</code></pre><p>A model for simulating fitnesses evolving over phylogenies using the HB98 model. <code>sites</code> is the number of sites, <code>alphas</code> is a vector of synonymous rates (one per site), <code>ou_params</code> is a vector of <code>PiecewiseOUModel</code>s (one per site), and <code>nuc_matrix</code> is the symmetric nucleotide substitution matrix (shared across sites). If &#39;rescale&#39; is true, then the nuc matrix is scaled so that, when <code>alpha=1</code> and the fitnesses<code>=0</code>, the HB model expects one substitution per site per unit time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/aebfdeedd90dd2754e3150178c09e039547f3106/src/simulations/ou_hb.jl#L211-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodonMolecularEvolution.ShiftingHBSimPartition" href="#CodonMolecularEvolution.ShiftingHBSimPartition"><code>CodonMolecularEvolution.ShiftingHBSimPartition</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ShiftingHBSimPartition(model::ShiftingHBSimModel; burnin_time = 100.0, code = MolecularEvolution.universal_code)</code></pre><p>Constructs a partition that tracks evolving fitnesses and codons. Only useable for sampling (not likelihood calculations).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/aebfdeedd90dd2754e3150178c09e039547f3106/src/simulations/ou_hb.jl#L232-L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodonMolecularEvolution.ShiftingNeHBSimModel-Union{Tuple{C}, Tuple{B}, Tuple{A}, Tuple{Matrix{Float64}, Array{PiecewiseOUModel{A, B, C}, 1}, PiecewiseOUModel}} where {A, B, C}" href="#CodonMolecularEvolution.ShiftingNeHBSimModel-Union{Tuple{C}, Tuple{B}, Tuple{A}, Tuple{Matrix{Float64}, Array{PiecewiseOUModel{A, B, C}, 1}, PiecewiseOUModel}} where {A, B, C}"><code>CodonMolecularEvolution.ShiftingNeHBSimModel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ShiftingNeHBSimModel(nuc_matrix, unscaled_ou_params, logNe_model; alpha, rescale, code)</code></pre><p>Create a model with one OU process per site (unscaled<em>ou</em>params) and one OU process for log(N<em>e).  <code>alpha</code> can be a scalar or a vector of the same length as unscaled</em>ou<em>params. If <code>rescale</code> is true, the nuc</em>matrix is scaled (HB98 neutral scaling).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/aebfdeedd90dd2754e3150178c09e039547f3106/src/simulations/ou_hb.jl#L596-L602">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodonMolecularEvolution.ShiftingNeHBSimPartition-Tuple{ShiftingNeHBSimModel}" href="#CodonMolecularEvolution.ShiftingNeHBSimPartition-Tuple{ShiftingNeHBSimModel}"><code>CodonMolecularEvolution.ShiftingNeHBSimPartition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ShiftingNeHBSimPartition(model; burnin_time)</code></pre><p>Constructs a partition for the <code>ShiftingNeHBSimModel</code>. Initializes by:</p><ul><li>Drawing random unscaled fitnesses from each site&#39;s OU equilibrium.</li><li>Drawing random logNe from its OU equilibrium.</li><li>&quot;Burning in&quot; each site along the branch of length <code>burnin_time</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/aebfdeedd90dd2754e3150178c09e039547f3106/src/simulations/ou_hb.jl#L634-L642">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodonMolecularEvolution.HB98AA_matrix-Tuple{Any, Any, Any}" href="#CodonMolecularEvolution.HB98AA_matrix-Tuple{Any, Any, Any}"><code>CodonMolecularEvolution.HB98AA_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">HB98AA_matrix(alpha, nuc_matrix, AA_fitness; genetic_code = MolecularEvolution.universal_code)</code></pre><p>Returns the rate matrix for a codon model using the HB98 model where each AA has a different fitness. <code>alpha</code> is the synonymous rate, <code>nuc_matrix</code> is the symmetric nucleotide substitution matrix, and <code>AA_fitness</code> is the fitness of each amino acid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/aebfdeedd90dd2754e3150178c09e039547f3106/src/simulations/ou_hb.jl#L44-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodonMolecularEvolution.HB98_row-NTuple{4, Any}" href="#CodonMolecularEvolution.HB98_row-NTuple{4, Any}"><code>CodonMolecularEvolution.HB98_row</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">HB98AA_row(current_codon, alpha, nuc_matrix, AA_fitness; genetic_code=MolecularEvolution.universal_code)</code></pre><p>Returns the rate row for a codon model using the HB98 model where each AA has a different fitness. <code>current_codon</code> is the current codon, <code>alpha</code> is the synonymous rate, <code>nuc_matrix</code> is the symmetric nucleotide substitution matrix, and <code>AA_fitness</code> is the fitness of each amino acid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/aebfdeedd90dd2754e3150178c09e039547f3106/src/simulations/ou_hb.jl#L132-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodonMolecularEvolution.HB_fixation_rate-Tuple{Any, Any}" href="#CodonMolecularEvolution.HB_fixation_rate-Tuple{Any, Any}"><code>CodonMolecularEvolution.HB_fixation_rate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">HB_fixation_rate(from_codon, to_codon)

Returns the fixation rate of a mutation from `from_codon` to `to_codon` under the HB98 model.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/aebfdeedd90dd2754e3150178c09e039547f3106/src/simulations/ou_hb.jl#L22-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodonMolecularEvolution.HBdNdS-Tuple{Vector{Float64}}" href="#CodonMolecularEvolution.HBdNdS-Tuple{Vector{Float64}}"><code>CodonMolecularEvolution.HBdNdS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">HBdNdS(fs::Vector{Float64}; code = MolecularEvolution.universal_code, nucm = CodonMolecularEvolution.demo_nucmat)
HBdNdS(fs_pre::Vector{Float64}, fs_post::Vector{Float64}; code = MolecularEvolution.universal_code, nucm = CodonMolecularEvolution.demo_nucmat)</code></pre><p>Returns the expected dN/dS ratio for a Halpern and Bruno model with a vector of fitnesses. If two vectors are provided, then the dN/dS ratio is computed for the shift from <code>fs_pre</code> to <code>fs_post</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/aebfdeedd90dd2754e3150178c09e039547f3106/src/simulations/ou_hb.jl#L313-L318">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodonMolecularEvolution.HBviz-Tuple{Vector{Float64}, Vector{Vector{Float64}}, Float64, Any, Any}" href="#CodonMolecularEvolution.HBviz-Tuple{Vector{Float64}, Vector{Vector{Float64}}, Float64, Any, Any}"><code>CodonMolecularEvolution.HBviz</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">HBviz(ts, fst, T, alp, nucm)</code></pre><p>Visualize over time the fitness trajectory, the codon frequencies, and the expected dN/dS. <code>ts</code> is a vector of times, <code>fst</code> is a vector of fitnesses, <code>T</code> is the total time, <code>alp</code> is the alpha parameter, and <code>nucm</code> is the nucleotide substitution matrix.</p><pre><code class="language-julia hljs">σ = 2.0
alpha = 1.0
nucm = CodonMolecularEvolution.demo_nucmat
fst = [randn(20) .* σ, randn(20) .* σ]
ts = [-100.0, 1.0]
T = 2.0
HBviz(ts, fst, T, alpha, nucm)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/aebfdeedd90dd2754e3150178c09e039547f3106/src/simulations/ou_hb.jl#L419-L433">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodonMolecularEvolution.benchmark_global_fit-Tuple{Any}" href="#CodonMolecularEvolution.benchmark_global_fit-Tuple{Any}"><code>CodonMolecularEvolution.benchmark_global_fit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CodonMolecularEvolution.benchmark_global_fit(benchmark_name; exports=true, data=1:5, optimize_branch_lengths=false)</code></pre><p>Benchmarks different implementations of the difFUBAR<em>global</em>fit algorithm. Results of the benchmark are printed out as a DataFrame and saved to a CSV file.  Uses the heuristic top pick to generate con lik matrices. Compares difference in con lik matrices. If exports is true, it also runs MCMCs on the con lik matrices and plots the means and posteriors of the different versions.</p><ul><li><code>benchmark_name</code> is the filepath to where the benchmark will be saved, if exports.</li><li><code>data</code> is the range/vector of datasets to run the benchmark on. By default, this is 1:5. These are the enumerated datasets:<ul><li><ol><li>Ace2nobackground</li></ol></li><li><ol><li>Ace2reallytiny</li></ol></li><li><ol><li>Ace2tiny</li></ol></li><li><ol><li>ParvoVP</li></ol></li><li><ol><li>ParvoVPregrouped</li></ol></li></ul></li><li><code>optimize_branch_lengths</code> is an option that can be either <code>true</code>, <code>false</code> or <code>&quot;detect&quot;</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/aebfdeedd90dd2754e3150178c09e039547f3106/test/benchmark_difFUBAR.jl#L253-L266">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodonMolecularEvolution.benchmark_grid-Tuple{Any}" href="#CodonMolecularEvolution.benchmark_grid-Tuple{Any}"><code>CodonMolecularEvolution.benchmark_grid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CodonMolecularEvolution.benchmark_grid(benchmark_name; exports=true, versions_option=1, t::Integer=0, data=1:5)</code></pre><p>Benchmarks different implementations of the difFUBAR_grid algorithm. Results of the benchmark are printed out as a DataFrame and saved to a CSV file.</p><ul><li><code>benchmark_name</code> is the filepath to where the benchmark will be saved, if exports</li><li><code>versions_option</code> have 4 different options:<ul><li><ol><li>default option, only run heuristic top pick</li></ol></li><li><ol><li>only run baseline version</li></ol></li><li><ol><li>run heuristic top pick and baseline version</li></ol></li><li><ol><li>run all versions</li></ol></li></ul></li><li><code>t</code> is the number of threads you want to use in the parallel versions. If specified and non-zero, this will override the number of threads chosen by the heuristic.</li><li><code>data</code> is the range/vector of datasets to run the benchmark on. By default, this is 1:5. These are the enumerated datasets:<ul><li><ol><li>Ace2nobackground</li></ol></li><li><ol><li>Ace2reallytiny</li></ol></li><li><ol><li>Ace2tiny</li></ol></li><li><ol><li>ParvoVP</li></ol></li><li><ol><li>ParvoVPregrouped</li></ol></li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/aebfdeedd90dd2754e3150178c09e039547f3106/test/benchmark_difFUBAR.jl#L193-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodonMolecularEvolution.dNdS-Tuple{Any, Any, Vector{Float64}}" href="#CodonMolecularEvolution.dNdS-Tuple{Any, Any, Vector{Float64}}"><code>CodonMolecularEvolution.dNdS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dNdS(q1, q0, p; code = MolecularEvolution.universal_code)
dNdS(q1, q0; code = MolecularEvolution.universal_code)</code></pre><p>Returns an analytic expectation of the dN/dS ratio for a codon model. <code>q1</code> is the rate matrix where selection is active (eg. a Halpern and Bruno model with a set of fitnesses), and <code>q0</code> is the corresponding rate matrix where selection is inactive (eg. a Halpern and Bruno model with all fitnesses equal). <code>p</code> is the frequency distribution over codons that the dN/dS ratio is computed against. If not provided, this is computed as the equilibrium from <code>q1</code>. If only a vector of fitnesses are provided, then the <code>q1</code>, <code>q0</code>, and <code>p</code> are computed assuming a Halpern and Bruno model.</p><pre><code class="nohighlight hljs">fs = randn(20)
nucm = CodonMolecularEvolution.demo_nucmat
q1 = HB98AA_matrix(1.0, nucm, fs)
q0 = HB98AA_matrix(1.0, nucm, zeros(20))
dNdS(q1, q0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/aebfdeedd90dd2754e3150178c09e039547f3106/src/simulations/ou_hb.jl#L283-L298">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodonMolecularEvolution.difFUBAR-NTuple{5, Any}" href="#CodonMolecularEvolution.difFUBAR-NTuple{5, Any}"><code>CodonMolecularEvolution.difFUBAR</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">difFUBAR(seqnames, seqs, treestring, tags, outpath; &lt;keyword arguments&gt;)</code></pre><p>Takes a tagged phylogeny and an alignment as input and performs difFUBAR analysis. Returns <code>df, results_tuple</code> where <code>df</code> is a DataFrame of the detected sites and <code>results_tuple</code> is a tuple of the partial calculations needed to re-run <code>difFUBAR_tabulate</code>. Consistent with the docs of <a href="..#CodonMolecularEvolution.difFUBAR_tabulate-NTuple{6, Any}"><code>difFUBAR_tabulate</code></a>, <code>results_tuple</code> stores <code>(alloc_grid, codon_param_vec, alphagrid, omegagrid, tag_colors)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>seqnames</code>: vector of untagged sequence names.</li><li><code>seqs</code>: vector of aligned sequences, corresponding to <code>seqnames</code>.</li><li><code>treestring</code>: a tagged newick tree string.</li><li><code>tags</code>: vector of tag signatures.</li><li><code>outpath</code>: export directory.</li><li><code>tag_colors=DIFFUBAR_TAG_COLORS[sortperm(tags)]</code>: vector of tag colors (hex format). The default option is consistent with the difFUBAR paper (Foreground 1: red, Foreground 2: blue).</li><li><code>pos_thresh=0.95</code>: threshold of significance for the posteriors.</li><li><code>iters=2500</code>: iterations used in the Gibbs sampler.</li><li><code>verbosity=1</code>: as verbosity increases, prints are added accumulatively. <ul><li>0 - no prints</li><li>1 - show current step and where output files are exported</li><li>2 - show the chosen <code>difFUBAR_grid</code> version and amount of parallel threads.</li></ul></li><li><code>exports=true</code>: if true, output files are exported.</li><li><code>code=MolecularEvolution.universal_code</code>: genetic code used for the analysis.</li><li><code>optimize_branch_lengths=false</code>: if true, the branch lengths of the phylogenetic tree are optimized.</li><li><code>version::Union{difFUBARGrid, Nothing}=nothing</code>: explicitly choose the version of <code>difFUBAR_grid</code> to use. If <code>nothing</code>, the version is heuristically chosen based on the available RAM and Julia threads.</li><li><code>t=0</code>: explicitly choose the amount of Julia threads to use. If <code>0</code>, the degree of parallelization is heuristically chosen based on the available RAM and Julia threads.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Julia starts up with a single thread of execution, by default. See <a href="https://docs.julialang.org/en/v1/manual/multi-threading/#Starting-Julia-with-multiple-threads">Starting Julia with multiple threads</a>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/aebfdeedd90dd2754e3150178c09e039547f3106/src/difFUBAR/difFUBAR.jl#L442-L470">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodonMolecularEvolution.difFUBAR_init-Tuple{Any, Any, Any}" href="#CodonMolecularEvolution.difFUBAR_init-Tuple{Any, Any, Any}"><code>CodonMolecularEvolution.difFUBAR_init</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/aebfdeedd90dd2754e3150178c09e039547f3106/src/difFUBAR/difFUBAR.jl#L143-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodonMolecularEvolution.difFUBAR_tabulate-NTuple{6, Any}" href="#CodonMolecularEvolution.difFUBAR_tabulate-NTuple{6, Any}"><code>CodonMolecularEvolution.difFUBAR_tabulate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">difFUBAR_tabulate(analysis_name, pos_thresh, alloc_grid, codon_param_vec, alphagrid, omegagrid; tag_colors=DIFFUBAR_TAG_COLORS, verbosity=1, sites_to_plot=nothing, exports=true)</code></pre><p>Takes the output of <code>difFUBAR</code> and tabulates the results. Returns a DataFrame of the detected sites. This function enables you to use the results of <code>difFUBAR</code> to tabulate the results with a different threshold.</p><p><strong>Arguments</strong></p><ul><li><code>analysis_name</code>: where to export the results.</li><li><code>pos_thresh</code>: threshold of significance for the posteriors.</li><li><code>alloc_grid</code>: contains the result of the Gibbs sampler.</li><li><code>codon_param_vec</code>: vector of codon parameters from difFUBAR.</li><li><code>alphagrid</code>: grid of alpha values.</li><li><code>omegagrid</code>: grid of omega values.</li><li><code>tag_colors</code>: colors of the tags.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/aebfdeedd90dd2754e3150178c09e039547f3106/src/difFUBAR/difFUBAR.jl#L270-L284">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodonMolecularEvolution.getpuresubclades-Tuple{MolecularEvolution.FelNode, Vector{String}}" href="#CodonMolecularEvolution.getpuresubclades-Tuple{MolecularEvolution.FelNode, Vector{String}}"><code>CodonMolecularEvolution.getpuresubclades</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getpuresubclades(tree::FelNode, tags::Vector{String})</code></pre><ul><li>Should usually be called on the root of the tree. Traverses the tree iteratively with a depth-first search to find roots of pure subclades, presuming that nodenames have been trailed with tags. Returns a Vector{FelNode} with root-nodes of the pure subclades.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/aebfdeedd90dd2754e3150178c09e039547f3106/src/difFUBAR/grids.jl#L92-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodonMolecularEvolution.import_colored_figtree_nexus_as_tagged_tree-Tuple{Any}" href="#CodonMolecularEvolution.import_colored_figtree_nexus_as_tagged_tree-Tuple{Any}"><code>CodonMolecularEvolution.import_colored_figtree_nexus_as_tagged_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">import_colored_figtree_nexus_as_tagged_tree(fname; custom_labels=String[])</code></pre><p>Takes a nexus file from FigTree, where branches have been colored. Replaces all color tags with group tags that can be used in the models. Can add custom labels too. Should consider an entire custom dictionary as well in future.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; treestring, tags, tag_colors = import_colored_figtree_nexus_as_tagged_tree(&quot;data/Ace2_no_background.nex&quot;)
(&quot;(((XM_027533928_Bos_indicus_x_Bos_taurus{G1}:0.097072,(XM_042974087_Panthera_tigris{G1}:0.038016,... more ...;&quot;, [&quot;{G2}&quot;, &quot;{G1}&quot;], [&quot;#ff0015&quot;, &quot;#0011ff&quot;])</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>treestring</code> is truncated. <a href="https://raw.githubusercontent.com/MurrellGroup/CodonMolecularEvolution.jl/main/test/data/Ace2_no_background/Ace2_no_background.nex">NEXUS tree file</a></p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/aebfdeedd90dd2754e3150178c09e039547f3106/src/shared/shared.jl#L14-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodonMolecularEvolution.import_grouped_label_tree-Tuple{Any}" href="#CodonMolecularEvolution.import_grouped_label_tree-Tuple{Any}"><code>CodonMolecularEvolution.import_grouped_label_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">import_grouped_label_tree(tree_file)</code></pre><p>Takes a Newick tree file and return Newick tree, Newick tree with replaced tags, group tags, original tags, and randomly generated colours for each tag</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/aebfdeedd90dd2754e3150178c09e039547f3106/src/shared/shared.jl#L150-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodonMolecularEvolution.import_labeled_phylotree_newick-Tuple{Any}" href="#CodonMolecularEvolution.import_labeled_phylotree_newick-Tuple{Any}"><code>CodonMolecularEvolution.import_labeled_phylotree_newick</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">import_labeled_phylotree_newick(fname)</code></pre><p>Import a tagged phylogeny from phylotree and return the treestring and tags.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/aebfdeedd90dd2754e3150178c09e039547f3106/src/shared/shared.jl#L186-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodonMolecularEvolution.jump-Tuple{Any, Any, PiecewiseOUModel}" href="#CodonMolecularEvolution.jump-Tuple{Any, Any, PiecewiseOUModel}"><code>CodonMolecularEvolution.jump</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">jump(x_source, m::PiecewiseOUModel)</code></pre><p>Evolves values over time using a piecewise constant approximation to an OU process, where this function computes the new distribution for a single discrete jump. <code>x_source</code> is the vector of fitnesses, and m is the PiecewiseOUModel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/aebfdeedd90dd2754e3150178c09e039547f3106/src/simulations/ou_hb.jl#L113-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodonMolecularEvolution.jumpy_HB_codon_evolve-NTuple{6, Any}" href="#CodonMolecularEvolution.jumpy_HB_codon_evolve-NTuple{6, Any}"><code>CodonMolecularEvolution.jumpy_HB_codon_evolve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">jumpy_HB_codon_evolve(fitnesses, codon, ou_model, nuc_matrix, alpha, time;
    genetic_code = MolecularEvolution.universal_code, push_into = nothing)</code></pre><p>Evolves fitnesses and codons over time using the HB98 model. <code>fitnesses</code> is the vector of fitnesses, <code>codon</code> is the current codon, <code>ou_model</code> is the OU model, <code>nuc_matrix</code> is the symmetric nucleotide substitution matrix, <code>alpha</code> is the synonymous rate, and <code>time</code> is the total time to evolve over.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/aebfdeedd90dd2754e3150178c09e039547f3106/src/simulations/ou_hb.jl#L162-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodonMolecularEvolution.jumpy_NeHB_codon_evolve-NTuple{6, Any}" href="#CodonMolecularEvolution.jumpy_NeHB_codon_evolve-NTuple{6, Any}"><code>CodonMolecularEvolution.jumpy_NeHB_codon_evolve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">jumpy_NeHB_codon_evolve(fitnesses, logNe_trajectory, codon, fitness_model, nuc_matrix, alpha;
genetic_code = MolecularEvolution.universal_code, push_into = nothing)</code></pre><p>Evolves codons and unscaled site-fitness, along with a given trajectory of log-pop-size.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/aebfdeedd90dd2754e3150178c09e039547f3106/src/simulations/ou_hb.jl#L518-L523">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodonMolecularEvolution.maxdNdS2std-Tuple{Any}" href="#CodonMolecularEvolution.maxdNdS2std-Tuple{Any}"><code>CodonMolecularEvolution.maxdNdS2std</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">maxdNdS2std(ω)</code></pre><p>Inverse of std2maxdNdS(σ). Estimates the standard deviation of the fitnesses that will produce, in expectation, a dN/dS ratio of <code>ω</code>, assuming Gaussian fitnesses and a Halpern and Bruno model, where the fitnesses have just shifted from one Gaussian sample to another. Note: this is not an analytical solution, but a serindipitously good approximation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/aebfdeedd90dd2754e3150178c09e039547f3106/src/simulations/ou_hb.jl#L350-L355">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodonMolecularEvolution.optimize_MG94_F3x4-Tuple{Any, Any, Any}" href="#CodonMolecularEvolution.optimize_MG94_F3x4-Tuple{Any, Any, Any}"><code>CodonMolecularEvolution.optimize_MG94_F3x4</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">optimize_MG94_F3x4(seqnames, seqs, tree; leaf_name_transform=x -&gt; x, genetic_code=MolecularEvolution.universal_code)</code></pre><p>Optimizes the MG94+F3x4 model on a tree, given a set of sequences and a tree. Returns the optimized tree, alpha, beta, nuc<em>matrix, F3x4, and eq</em>freqs. The leaf<em>name</em>transform kwarg can be used to transform the leaf names in the tree to match the seqnames.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/aebfdeedd90dd2754e3150178c09e039547f3106/src/shared/shared.jl#L201-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodonMolecularEvolution.shiftingHBviz-NTuple{6, Any}" href="#CodonMolecularEvolution.shiftingHBviz-NTuple{6, Any}"><code>CodonMolecularEvolution.shiftingHBviz</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shiftingHBviz(T, event_rate, σ, mixing_rate, alpha, nucm; T0 = -20)</code></pre><p>Visualize the fitness trajectory, codon frequencies, and expected dN/dS over time for a shifting HB process. <code>T</code> is the total time, <code>event_rate</code> is the rate of fitness shifts, <code>σ</code> is the standard deviation of the fitnesses, <code>mixing_rate</code> is the rate of mixing between fitnesses, <code>alpha</code> is the alpha parameter, and <code>nucm</code> is the nucleotide substitution matrix. <code>T0</code> controls the burnin time, to ensure the process is at equilibrium at <code>t=0</code>.</p><pre><code class="language-julia hljs">T = 2.0
mix = 1.0
σ = 5.0
event_rate = 100.0
alpha = 1.0
nucm = CodonMolecularEvolution.demo_nucmat
shiftingHBviz(T, event_rate, σ, mix, alpha, nucm)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/aebfdeedd90dd2754e3150178c09e039547f3106/src/simulations/ou_hb.jl#L477-L494">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodonMolecularEvolution.shiftingNeHBviz-NTuple{10, Any}" href="#CodonMolecularEvolution.shiftingNeHBviz-NTuple{10, Any}"><code>CodonMolecularEvolution.shiftingNeHBviz</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shiftingNeHBviz(T, f_event_rate, f_σ, f_mixing_rate, logNe_event_rate, logNe_σ, logNe_mean, logNe_mixing_rate, alpha, nucm; T0 = -20)</code></pre><p>Visualize the Ne trajectory, fitness trajectory, codon frequencies, and expected dN/dS over time for a shifting Ne HB process.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/aebfdeedd90dd2754e3150178c09e039547f3106/src/simulations/ou_hb.jl#L561-L565">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodonMolecularEvolution.sim_alphabeta_seqs-Tuple{Vector{Float64}, Vector{Float64}, Any, Matrix{Float64}, Matrix{Float64}}" href="#CodonMolecularEvolution.sim_alphabeta_seqs-Tuple{Vector{Float64}, Vector{Float64}, Any, Matrix{Float64}, Matrix{Float64}}"><code>CodonMolecularEvolution.sim_alphabeta_seqs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sim_alphabeta_seqs(alphavec::Vector{Float64}, betavec::Vector{Float64}, singletree, nucmat::Array{Float64,2}, f3x4::Array{Float64,2};
                        scale_total_tree_neutral_expected_subs = -1.0, outpath = &quot;&quot;)</code></pre><p>Simulate a set of sequences under a given tree, with a set of alpha and beta values. f3x4 is a 3-by-4 matrix of position-specific nucleotide frequencies. nucmat is a 4-by-4 matrix of nucleotide substitution rates. If scale<em>total</em>tree<em>neutral</em>expected<em>subs &gt; 0, then the tree is scaled so that if alpha=beta=1 for all sites, the expected number of neutral substitutions is equal to scale</em>total<em>tree</em>neutral<em>expected</em>subs. The sequences are written to a fasta file, and the tree is written to a newick file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/aebfdeedd90dd2754e3150178c09e039547f3106/src/simulations/alphabeta/alphabeta.jl#L23-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodonMolecularEvolution.std2maxdNdS-Tuple{Any}" href="#CodonMolecularEvolution.std2maxdNdS-Tuple{Any}"><code>CodonMolecularEvolution.std2maxdNdS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">std2maxdNdS(σ)</code></pre><p>Approximation for the maximum dN/dS ratio as a function of the standard deviation of the fitnesses, assuming Gaussian fitnesses and a Halpern and Bruno model, where the fitnesses have just shifted from one Gaussian sample to another. Note: this is not an analytical solution, but a serindipitously good approximation.</p><pre><code class="nohighlight hljs">function monte_carlo_maxdNdS(σ; N=100_000)
    sum_val = 0.0
    for _ in 1:N
        f_i = σ * randn()
        f_j = σ * randn()
        sum_val += HB_fixation_rate(f_i, f_j)
    end
    return sum_val / N
end
vs = 0:0.01:10
plot(vs, monte_carlo_maxdNdS.(vs), label = &quot;Monte Carlo&quot;, alpha = 0.8)
plot!(vs, std2maxdNdS.(vs), label = &quot;Approx&quot;, linestyle = :dash, alpha = 0.8)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/aebfdeedd90dd2754e3150178c09e039547f3106/src/simulations/ou_hb.jl#L327-L347">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CodonMolecularEvolution.time_varying_HB_freqs-NTuple{4, Any}" href="#CodonMolecularEvolution.time_varying_HB_freqs-NTuple{4, Any}"><code>CodonMolecularEvolution.time_varying_HB_freqs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">time_varying_HB_freqs(ts, T, fst, init_freqs; nucm = CodonMolecularEvolution.demo_nucmat, alpha = 1.0, delta_t = 0.002, prezero_delta_t = 0.5)</code></pre><p>Compute the time-varying codon frequencies and expected dN/dS over time for a sequence of fitnesses, under the Halpern-Bruno model. <code>ts</code> is a vector of times, <code>T</code> is the total time, <code>fst</code> is a vector of vector of fitnesses, <code>init_freqs</code> is the initial codon frequencies, <code>nucm</code> is the nucleotide substitution matrix, <code>alpha</code> is the alpha parameter, <code>delta_t</code> is the discretization time step for the simulation, and <code>prezero_delta_t</code> is the time step used before <code>t=0</code>. <code>fst[i]</code> is assumed to be the fitness between <code>t = ts[i]</code> and <code>t = ts[i+1]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/aebfdeedd90dd2754e3150178c09e039547f3106/src/simulations/ou_hb.jl#L358-L365">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MolecularEvolution.forward!-Tuple{ShiftingNeHBSimPartition, ShiftingNeHBSimPartition, ShiftingNeHBSimModel, MolecularEvolution.FelNode}" href="#MolecularEvolution.forward!-Tuple{ShiftingNeHBSimPartition, ShiftingNeHBSimPartition, ShiftingNeHBSimModel, MolecularEvolution.FelNode}"><code>MolecularEvolution.forward!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">forward!(dest, source, model, node)</code></pre><p>Evolves <code>source</code> partition along <code>node.branchlength</code> under <code>model</code>, storing the result in <code>dest</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MurrellGroup/CodonMolecularEvolution.jl/blob/aebfdeedd90dd2754e3150178c09e039547f3106/src/simulations/ou_hb.jl#L696-L700">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="difFUBAR/">difFUBAR »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 29 April 2025 09:22">Tuesday 29 April 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

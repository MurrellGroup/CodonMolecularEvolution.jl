var documenterSearchIndex = {"docs":
[{"location":"fitness_OU/#Simulating-with-time-varying-fitness","page":"Simulating with time-varying fitness","title":"Simulating with time-varying fitness","text":"","category":"section"},{"location":"fitness_OU/","page":"Simulating with time-varying fitness","title":"Simulating with time-varying fitness","text":"Uses this tree as input.","category":"page"},{"location":"fitness_OU/","page":"Simulating with time-varying fitness","title":"Simulating with time-varying fitness","text":"#Read in a tree where the Newick string has tags (eg. \"{G1}\" or \"{G2}\") on branches.\n#Can be tagged with: https://murrellgroup.github.io/WebWidgets/phylotagger.html\nts, tags = import_labeled_phylotree_newick(\"simtree_tagged.tre\")\ntree = gettreefromnewick(ts, FelNode)\n\n#First viz at the tree with tags\nfor (i,n) in enumerate(getnodelist(tree))\n    (length(n.children) > 0) && (n.name = \"N$(i)_\"*n.name) #Make internal node names unique (only needed for plotting)\n    n.node_data = Dict(\"g\" => (occursin(tags[2], n.name) ? 1.0 : 0.0))\nend\npl = plot(get_phylo_tree(tree), showtips = false, marker_z = \"g\", line_z = \"g\", markerstrokewidth = 0, colorbar = false, linecolor = :darkrainbow, markercolor = :darkrainbow)\nsavefig(\"tagged_simtree_phylo.svg\")","category":"page"},{"location":"fitness_OU/","page":"Simulating with time-varying fitness","title":"Simulating with time-varying fitness","text":"(Image: )","category":"page"},{"location":"fitness_OU/","page":"Simulating with time-varying fitness","title":"Simulating with time-varying fitness","text":"#500 codon sites in total, where 100 will undergo a fitness shift:\nS, nsel = 500, 100\nselsites = sort(sample(1:S, nsel, replace = false))\nnucm = CodonMolecularEvolution.demo_nucmat #Using a nuc matrix derived from a flu dataset\n\n#Compute std dev of fitnesses for the target peak dN/dS, aiming for a mean dN/dS of 2.0 at the fitness shift boundary:\nσ = maxdNdS2std(2.0)\nm0fs = randn(20,S) .* σ\nm1fs = copy(m0fs)\nm1fs[:,selsites] .= randn(20,nsel) .* σ\n\n#Plot analytical expectations for background dN/dS, and for peak dN/dS at the host change boundary.\nscatter([HBdNdS(m0fs[:,i], nucm = nucm) for i in 1:S], size = (1200,500), yscale = :log10, label = \"HBω0\", msw = 0, color = \"blue\", xlabel = \"Site\", ylabel = \"dN/dS\", margins = 1Plots.cm)\nscatter!(selsites, [HBdNdS(m0fs[:,i], m1fs[:,i], nucm = nucm) for i in selsites], size = (1200,500), label = \"HBω1\", msw = 0, color = \"red\")\nsavefig(\"dnds_plot.svg\")","category":"page"},{"location":"fitness_OU/","page":"Simulating with time-varying fitness","title":"Simulating with time-varying fitness","text":"(Image: )","category":"page"},{"location":"fitness_OU/","page":"Simulating with time-varying fitness","title":"Simulating with time-varying fitness","text":"#Specify two models, m1 and m2, sharing alpha but with different fitnesses for the `selsites` sites:\nusing Distributions\n\nalphas = rand(Gamma(10,0.1), S)\nm1 = ShiftingHBSimModel(S, alphas, [PiecewiseOUModel(m0fs[:,i]) for i in 1:S], nucm)\nm2 = ShiftingHBSimModel(S, alphas, [PiecewiseOUModel(m1fs[:,i]) for i in 1:S], nucm)\n\n#Use model m1 when \"{G1}\" occurs in the sequence name. Models are in [] because we have an array of models per partition, when passing a function:\nmfunc(n) = occursin(\"{G2}\", n.name) ? [m2] : [m1]\n\n#The process should be at equilibrium for whatever the root model is, and this will use the root model:\ninternal_message_init!(tree, ShiftingHBSimPartition(m1))\n\n#Simeulate under this process:\nsample_down!(tree, mfunc)\n\n#Write sequences to a .fasta file:\nwrite_fasta(\"simu_seqs.fasta\", leaf_samples(tree), seq_names = leaf_names(tree))","category":"page"},{"location":"shared/#Shared-tools","page":"Shared tools","title":"Shared tools","text":"","category":"section"},{"location":"shared/","page":"Shared tools","title":"Shared tools","text":"These tools are shared between the models.","category":"page"},{"location":"shared/#Tree-importing","page":"Shared tools","title":"Tree importing","text":"","category":"section"},{"location":"shared/","page":"Shared tools","title":"Shared tools","text":"import_colored_figtree_nexus_as_tagged_tree\nimport_grouped_label_tree\nimport_labeled_phylotree_newick","category":"page"},{"location":"shared/#CodonMolecularEvolution.import_colored_figtree_nexus_as_tagged_tree","page":"Shared tools","title":"CodonMolecularEvolution.import_colored_figtree_nexus_as_tagged_tree","text":"import_colored_figtree_nexus_as_tagged_tree(fname; custom_labels=String[])\n\nTakes a nexus file from FigTree, where branches have been colored. Replaces all color tags with group tags that can be used in the models. Can add custom labels too. Should consider an entire custom dictionary as well in future.\n\nExamples\n\njulia> treestring, tags, tag_colors = import_colored_figtree_nexus_as_tagged_tree(\"data/Ace2_no_background.nex\")\n(\"(((XM_027533928_Bos_indicus_x_Bos_taurus{G1}:0.097072,(XM_042974087_Panthera_tigris{G1}:0.038016,... more ...;\", [\"{G2}\", \"{G1}\"], [\"#ff0015\", \"#0011ff\"])\n\nnote: Note\ntreestring is truncated. NEXUS tree file\n\n\n\n\n\n","category":"function"},{"location":"shared/#CodonMolecularEvolution.import_grouped_label_tree","page":"Shared tools","title":"CodonMolecularEvolution.import_grouped_label_tree","text":"import_grouped_label_tree(tree_file)\n\nTakes a Newick tree file and return Newick tree, Newick tree with replaced tags, group tags, original tags, and randomly generated colours for each tag\n\n\n\n\n\n","category":"function"},{"location":"shared/#CodonMolecularEvolution.import_labeled_phylotree_newick","page":"Shared tools","title":"CodonMolecularEvolution.import_labeled_phylotree_newick","text":"import_labeled_phylotree_newick(fname)\n\nImport a tagged phylogeny from phylotree and return the treestring and tags.\n\n\n\n\n\n","category":"function"},{"location":"shared/#Model-fitting","page":"Shared tools","title":"Model fitting","text":"","category":"section"},{"location":"shared/","page":"Shared tools","title":"Shared tools","text":"CodonMolecularEvolution.optimize_MG94_F3x4","category":"page"},{"location":"shared/#CodonMolecularEvolution.optimize_MG94_F3x4","page":"Shared tools","title":"CodonMolecularEvolution.optimize_MG94_F3x4","text":"optimize_MG94_F3x4(seqnames, seqs, tree; leaf_name_transform=x -> x, genetic_code=MolecularEvolution.universal_code)\n\nOptimizes the MG94+F3x4 model on a tree, given a set of sequences and a tree. Returns the optimized tree, alpha, beta, nucmatrix, F3x4, and eqfreqs. The leafnametransform kwarg can be used to transform the leaf names in the tree to match the seqnames.\n\n\n\n\n\n","category":"function"},{"location":"shared/#Misc","page":"Shared tools","title":"Misc","text":"","category":"section"},{"location":"dataprep/#Data-preparation","page":"Data preparation","title":"Data preparation","text":"","category":"section"},{"location":"dataprep/#Branch-tagging","page":"Data preparation","title":"Branch tagging","text":"","category":"section"},{"location":"dataprep/","page":"Data preparation","title":"Data preparation","text":"Starting from this phylogeny untagged newick file,  (Image: )","category":"page"},{"location":"dataprep/","page":"Data preparation","title":"Data preparation","text":"an alternative we can use for branch tagging is the phylotree web application. See phylotree tutorial for details on how to do this.","category":"page"},{"location":"dataprep/","page":"Data preparation","title":"Data preparation","text":"Then, after a few button clicks in the app, we get a tagged newick file","category":"page"},{"location":"dataprep/","page":"Data preparation","title":"Data preparation","text":"(Image: )","category":"page"},{"location":"dataprep/","page":"Data preparation","title":"Data preparation","text":"We can extract the treestring and the tags from the newick file with import_labeled_phylotree_newick","category":"page"},{"location":"difFUBAR/#difFUBAR","page":"difFUBAR","title":"difFUBAR","text":"","category":"section"},{"location":"difFUBAR/","page":"difFUBAR","title":"difFUBAR","text":"An interface to difFUBAR (awaiting the correct link)","category":"page"},{"location":"difFUBAR/#Example","page":"difFUBAR","title":"Example","text":"","category":"section"},{"location":"difFUBAR/","page":"difFUBAR","title":"difFUBAR","text":"Reads codon sequences from this FASTA file, and a tagged phylogeny from this NEXUS tree file.","category":"page"},{"location":"difFUBAR/","page":"difFUBAR","title":"difFUBAR","text":"using MolecularEvolution, FASTX, CodonMolecularEvolution\nanalysis_name = \"output/Ace2\"\nseqnames,seqs = read_fasta(\"data/Ace2_tiny_test.fasta\");\ntreestring, tags, tag_colors = import_colored_figtree_nexus_as_tagged_tree(\"data/Ace2_no_background.nex\")\ndf,results = difFUBAR(seqnames, seqs, treestring, tags, analysis_name);","category":"page"},{"location":"difFUBAR/","page":"difFUBAR","title":"difFUBAR","text":"Step 1: Initialization. If exports = true, tree showing the assignment of branches to groups/colors will be exported to: output/Ace2_tagged_input_tree.svg.\nStep 2: Optimizing global codon model parameters.\n0.0% 29.0% 58.0% 87.0% \nStep 4: Running Gibbs sampler to infer site categories.\nStep 5: Tabulating and plotting. Detected sites:\nSite 3 - P(ω1 > ω2):0.0075; P(ω2 > ω1):0.9805; P(ω1 > 1):0.1205; P(ω2 > 1):0.9675\nSite 13 - P(ω1 > ω2):0.0175; P(ω2 > ω1):0.9605; P(ω1 > 1):0.13; P(ω2 > 1):0.9305\n\nIf exports = true, writing results for all sites to CSV: output/Ace2_posteriors.csv\nPlotting alpha and omega distributions. If exports = true, saved as output/Ace2_violin_*.pdf","category":"page"},{"location":"difFUBAR/","page":"difFUBAR","title":"difFUBAR","text":"Here's a selection of the output files:","category":"page"},{"location":"difFUBAR/","page":"difFUBAR","title":"difFUBAR","text":"output/Ace2_tagged_input_tree.svg","category":"page"},{"location":"difFUBAR/","page":"difFUBAR","title":"difFUBAR","text":"(Image: )","category":"page"},{"location":"difFUBAR/","page":"difFUBAR","title":"difFUBAR","text":"note: Note\ndifFUBAR allows for an optional, untagged, background branch set.","category":"page"},{"location":"difFUBAR/","page":"difFUBAR","title":"difFUBAR","text":"output/Ace2_site_omega_means.pdf","category":"page"},{"location":"difFUBAR/","page":"difFUBAR","title":"difFUBAR","text":"(Image: )","category":"page"},{"location":"difFUBAR/","page":"difFUBAR","title":"difFUBAR","text":"output/Ace2_violin_all_params.pdf","category":"page"},{"location":"difFUBAR/","page":"difFUBAR","title":"difFUBAR","text":"(Image: )","category":"page"},{"location":"difFUBAR/","page":"difFUBAR","title":"difFUBAR","text":"note: Note\nThe output has a stochastic element to it due to the MCMC.","category":"page"},{"location":"difFUBAR/#Interface","page":"difFUBAR","title":"Interface","text":"","category":"section"},{"location":"difFUBAR/","page":"difFUBAR","title":"difFUBAR","text":"difFUBAR","category":"page"},{"location":"difFUBAR/#CodonMolecularEvolution.difFUBAR","page":"difFUBAR","title":"CodonMolecularEvolution.difFUBAR","text":"difFUBAR(seqnames, seqs, treestring, tags, outpath; <keyword arguments>)\n\nTakes a tagged phylogeny and an alignment as input and performs difFUBAR analysis. Returns df, results_tuple where df is a DataFrame of the detected sites and results_tuple is a tuple of the partial calculations needed to re-run difFUBAR_tabulate. Consistent with the docs of difFUBAR_tabulate, results_tuple stores (alloc_grid, codon_param_vec, alphagrid, omegagrid, tag_colors).\n\nArguments\n\nseqnames: vector of untagged sequence names.\nseqs: vector of aligned sequences, corresponding to seqnames.\ntreestring: a tagged newick tree string.\ntags: vector of tag signatures.\noutpath: export directory.\ntag_colors=DIFFUBAR_TAG_COLORS[sortperm(tags)]: vector of tag colors (hex format). The default option is consistent with the difFUBAR paper (Foreground 1: red, Foreground 2: blue).\npos_thresh=0.95: threshold of significance for the posteriors.\niters=2500: iterations used in the Gibbs sampler.\nbinarize=false: if true, the tree is binarized before the analysis.\nverbosity=1: as verbosity increases, prints are added accumulatively. \n0 - no prints\n1 - show current step and where output files are exported\n2 - show the chosen difFUBAR_grid version and amount of parallel threads.\nexports=true: if true, output files are exported.\ncode=MolecularEvolution.universal_code: genetic code used for the analysis.\noptimize_branch_lengths=false: if true, the branch lengths of the phylogenetic tree are optimized.\nversion::Union{difFUBARGrid, Nothing}=nothing: explicitly choose the version of difFUBAR_grid to use. If nothing, the version is heuristically chosen based on the available RAM and Julia threads.\nt=0: explicitly choose the amount of Julia threads to use. If 0, the degree of parallelization is heuristically chosen based on the available RAM and Julia threads.\n\nnote: Note\nJulia starts up with a single thread of execution, by default. See Starting Julia with multiple threads.\n\n\n\n\n\n","category":"function"},{"location":"difFUBAR/#For-a-simple-and-often-optimal-configuration","page":"difFUBAR","title":"For a simple and often optimal configuration","text":"","category":"section"},{"location":"difFUBAR/","page":"difFUBAR","title":"difFUBAR","text":"Launch Julia in the following manner: julia -t auto\nKeep the default values of the kwargs version and t","category":"page"},{"location":"difFUBAR/","page":"difFUBAR","title":"difFUBAR","text":"This lets Julia decide the amount of Julia threads and lets CodonMolecularEvolution.jl decide the difFUBARGrid subtype to dispatch on and the degree of parallelization.","category":"page"},{"location":"difFUBAR/#difFUBARGrid","page":"difFUBAR","title":"difFUBARGrid","text":"","category":"section"},{"location":"difFUBAR/","page":"difFUBAR","title":"difFUBAR","text":"Subtypes that decide which method to use for the grid likelihood computations.","category":"page"},{"location":"difFUBAR/","page":"difFUBAR","title":"difFUBAR","text":"difFUBARBaseline\ndifFUBARParallel\ndifFUBARTreesurgery\ndifFUBARTreesurgeryAndParallel","category":"page"},{"location":"difFUBAR/#CodonMolecularEvolution.difFUBARBaseline","page":"difFUBAR","title":"CodonMolecularEvolution.difFUBARBaseline","text":"Constructor\n\ndifFUBARBaseline()\n\nDescription\n\nUse the trivial implementation of the grid likelihood computations, i.e. 1 thread without sub-tree likelihood caching.\n\nSee also: difFUBARParallel, difFUBARTreesurgery, difFUBARTreesurgeryAndParallel.\n\n\n\n\n\n","category":"type"},{"location":"difFUBAR/#CodonMolecularEvolution.difFUBARParallel","page":"difFUBAR","title":"CodonMolecularEvolution.difFUBARParallel","text":"Constructor\n\ndifFUBARParallel()\n\nDescription\n\nExtend the baseline version by parallelizing the grid calculations. Requires julia to be launched with the t switch. Using t computational threads, where t is sufficiently small, memory complexity is usually O(t) and time complexity O(1/t). Empirical tests suggests that t should not be higher than the machine's total CPU threads and usually not higher than half of it's total threads.\n\nSee also: difFUBARBaseline, difFUBARTreesurgery, difFUBARTreesurgeryAndParallel.\n\n\n\n\n\n","category":"type"},{"location":"difFUBAR/#CodonMolecularEvolution.difFUBARTreesurgery","page":"difFUBAR","title":"CodonMolecularEvolution.difFUBARTreesurgery","text":"Constructor\n\ndifFUBARTreesurgery()\n\nDescription\n\nUse sub-tree likelihood caching described in the \"Methods\" section of the difFUBAR paper. Use more memory than the baseline version but be significantly faster, if purity is high.\n\nSee also: difFUBARBaseline, difFUBARParallel, difFUBARTreesurgeryAndParallel.\n\n\n\n\n\n","category":"type"},{"location":"difFUBAR/#CodonMolecularEvolution.difFUBARTreesurgeryAndParallel","page":"difFUBAR","title":"CodonMolecularEvolution.difFUBARTreesurgeryAndParallel","text":"Constructor\n\ndifFUBARTreesurgeryAndParallel()\n\nDescription\n\nUse parallelization and sub-tree likelihood caching. The most performant version in most cases. Use more memory than other versions.\n\nSee also: difFUBARBaseline, difFUBARTreesurgery, difFUBARParallel.\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = CodonMolecularEvolution","category":"page"},{"location":"#CodonMolecularEvolution","page":"Home","title":"CodonMolecularEvolution","text":"","category":"section"},{"location":"#A-Julia-package-for-popular-and-new-codon-models-of-molecular-evolution.","page":"Home","title":"A Julia package for popular and new codon models of molecular evolution.","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for CodonMolecularEvolution.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Descendant of MolecularEvolution.jl, specializing in codon models.","category":"page"},{"location":"#Collection-of-codon-model-methods","page":"Home","title":"Collection of codon model methods","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"difFUBAR: Scalable Bayesian comparison of selection pressure\nPerform a site-wise comparison of evolutionary pressure between two selected sets of branches.\nAuthors: Hassan Sadiq, Venkatesh Kumar, and Ben Murrell (original model development), Patrick Truong (benchmarking), Maximilian Danielsson (performance optimization).","category":"page"},{"location":"#Design-principles","page":"Home","title":"Design principles","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"User-facing\nUsers with no Julia experience should be able to run these models.\nScalability\nModels should scale to large, real-world datasets. To keep the memory footprint down, we use MolecularEvolution.jls LazyPartition when possible.\nPerformance\nWe try to maintain competitive runtimes by using e.g. computational shortcuts and parallelization whenever we can.","category":"page"},{"location":"#Package-Authors-and-Maintainers","page":"Home","title":"Package Authors and Maintainers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Maximilian Danielsson and Ben Murrell. Authors for specific models listed above.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [CodonMolecularEvolution]","category":"page"},{"location":"#CodonMolecularEvolution.PiecewiseOUModel","page":"Home","title":"CodonMolecularEvolution.PiecewiseOUModel","text":"PiecewiseOUModel(event_rate::Float64, eq_std::Float64, mixing::Float64; delta_t = 1.0)\nPiecewiseOUModel(offsets::Vector{Float64})\nPiecewiseOUModel(event_rate::Float64, eq_std::Float64, mixing::Float64, mu::Union{Float64,Vector{Float64}}, offsets::Union{Float64,Vector{Float64}}, codon_offsets::Union{Float64,Vector{Float64}})\n\nA piecewise constant approximation to an OU process, intended to simulate fitnesses evolving over phylogenies. The equilibrium standard deviation is directly parameterized (eq_std), as is the rate at which the process mixes to equilibrium (mixing). event_rate controls how often the fitness changes occur, where the mixing rate is scaled to compensate for the increased rate of change to achieve approximately the same amount of change per unit time even as the event_rate changes. A very high event_rate will behave more like continuous diffusion, but will be more computationally expensive to sample from. mu can also be set to control the mean fitnesses. The model also permits offsets, which are added to the fitnesses as they are passed into the model. For a single process, these are confounded with the mean mu but if the offsets change (eg. from one branch to another) the effective fitnesses will immidiately change, whereas if mu changes the fitnesses will drift towards mu.\n\n\n\n\n\n","category":"type"},{"location":"#CodonMolecularEvolution.ShiftingHBSimModel","page":"Home","title":"CodonMolecularEvolution.ShiftingHBSimModel","text":"ShiftingHBSimModel(sites, alphas, ou_params, nuc_matrix; rescale = true)\n\nA model for simulating fitnesses evolving over phylogenies using the HB98 model. sites is the number of sites, alphas is a vector of synonymous rates (one per site), ou_params is a vector of PiecewiseOUModels (one per site), and nuc_matrix is the symmetric nucleotide substitution matrix (shared across sites). If 'rescale' is true, then the nuc matrix is scaled so that, when alpha=1 and the fitnesses=0, the HB model expects one substitution per site per unit time.\n\n\n\n\n\n","category":"type"},{"location":"#CodonMolecularEvolution.ShiftingHBSimPartition","page":"Home","title":"CodonMolecularEvolution.ShiftingHBSimPartition","text":"ShiftingHBSimPartition(model::ShiftingHBSimModel; burnin_time = 100.0, code = MolecularEvolution.universal_code)\n\nConstructs a partition that tracks evolving fitnesses and codons. Only useable for sampling (not likelihood calculations).\n\n\n\n\n\n","category":"type"},{"location":"#CodonMolecularEvolution.ShiftingNeHBSimModel-Union{Tuple{C}, Tuple{B}, Tuple{A}, Tuple{Matrix{Float64}, Array{PiecewiseOUModel{A, B, C}, 1}, PiecewiseOUModel}} where {A, B, C}","page":"Home","title":"CodonMolecularEvolution.ShiftingNeHBSimModel","text":"ShiftingNeHBSimModel(nuc_matrix, unscaled_ou_params, logNe_model; alpha, rescale, code)\n\nCreate a model with one OU process per site (unscaledouparams) and one OU process for log(Ne).  alpha can be a scalar or a vector of the same length as unscaledouparams. If rescale is true, the nucmatrix is scaled (HB98 neutral scaling).\n\n\n\n\n\n","category":"method"},{"location":"#CodonMolecularEvolution.ShiftingNeHBSimPartition-Tuple{ShiftingNeHBSimModel}","page":"Home","title":"CodonMolecularEvolution.ShiftingNeHBSimPartition","text":"ShiftingNeHBSimPartition(model; burnin_time)\n\nConstructs a partition for the ShiftingNeHBSimModel. Initializes by:\n\nDrawing random unscaled fitnesses from each site's OU equilibrium.\nDrawing random logNe from its OU equilibrium.\n\"Burning in\" each site along the branch of length burnin_time.\n\n\n\n\n\n","category":"method"},{"location":"#CodonMolecularEvolution.HB98AA_matrix-Tuple{Any, Any, Any}","page":"Home","title":"CodonMolecularEvolution.HB98AA_matrix","text":"HB98AA_matrix(alpha, nuc_matrix, AA_fitness; genetic_code = MolecularEvolution.universal_code)\n\nReturns the rate matrix for a codon model using the HB98 model where each AA has a different fitness. alpha is the synonymous rate, nuc_matrix is the symmetric nucleotide substitution matrix, and AA_fitness is the fitness of each amino acid.\n\n\n\n\n\n","category":"method"},{"location":"#CodonMolecularEvolution.HB98_row-NTuple{4, Any}","page":"Home","title":"CodonMolecularEvolution.HB98_row","text":"HB98AA_row(current_codon, alpha, nuc_matrix, AA_fitness; genetic_code=MolecularEvolution.universal_code)\n\nReturns the rate row for a codon model using the HB98 model where each AA has a different fitness. current_codon is the current codon, alpha is the synonymous rate, nuc_matrix is the symmetric nucleotide substitution matrix, and AA_fitness is the fitness of each amino acid.\n\n\n\n\n\n","category":"method"},{"location":"#CodonMolecularEvolution.HB_fixation_rate-Tuple{Any, Any}","page":"Home","title":"CodonMolecularEvolution.HB_fixation_rate","text":"HB_fixation_rate(from_codon, to_codon)\n\nReturns the fixation rate of a mutation from `from_codon` to `to_codon` under the HB98 model.\n\n\n\n\n\n","category":"method"},{"location":"#CodonMolecularEvolution.HBdNdS-Tuple{Vector{Float64}}","page":"Home","title":"CodonMolecularEvolution.HBdNdS","text":"HBdNdS(fs::Vector{Float64}; code = MolecularEvolution.universal_code, nucm = CodonMolecularEvolution.demo_nucmat)\nHBdNdS(fs_pre::Vector{Float64}, fs_post::Vector{Float64}; code = MolecularEvolution.universal_code, nucm = CodonMolecularEvolution.demo_nucmat)\n\nReturns the expected dN/dS ratio for a Halpern and Bruno model with a vector of fitnesses. If two vectors are provided, then the dN/dS ratio is computed for the shift from fs_pre to fs_post.\n\n\n\n\n\n","category":"method"},{"location":"#CodonMolecularEvolution.HBviz-Tuple{Vector{Float64}, Vector{Vector{Float64}}, Float64, Any, Any}","page":"Home","title":"CodonMolecularEvolution.HBviz","text":"HBviz(ts, fst, T, alp, nucm)\n\nVisualize over time the fitness trajectory, the codon frequencies, and the expected dN/dS. ts is a vector of times, fst is a vector of fitnesses, T is the total time, alp is the alpha parameter, and nucm is the nucleotide substitution matrix.\n\nσ = 2.0\nalpha = 1.0\nnucm = CodonMolecularEvolution.demo_nucmat\nfst = [randn(20) .* σ, randn(20) .* σ]\nts = [-100.0, 1.0]\nT = 2.0\nHBviz(ts, fst, T, alpha, nucm)\n\n\n\n\n\n","category":"method"},{"location":"#CodonMolecularEvolution.benchmark_global_fit-Tuple{Any}","page":"Home","title":"CodonMolecularEvolution.benchmark_global_fit","text":"CodonMolecularEvolution.benchmark_global_fit(benchmark_name; exports=true, data=1:5, optimize_branch_lengths=false)\n\nBenchmarks different implementations of the difFUBARglobalfit algorithm. Results of the benchmark are printed out as a DataFrame and saved to a CSV file.  Uses the heuristic top pick to generate con lik matrices. Compares difference in con lik matrices. If exports is true, it also runs MCMCs on the con lik matrices and plots the means and posteriors of the different versions.\n\nbenchmark_name is the filepath to where the benchmark will be saved, if exports.\ndata is the range/vector of datasets to run the benchmark on. By default, this is 1:5. These are the enumerated datasets:\nAce2nobackground\nAce2reallytiny\nAce2tiny\nParvoVP\nParvoVPregrouped\noptimize_branch_lengths is an option that can be either true, false or \"detect\"\n\n\n\n\n\n","category":"method"},{"location":"#CodonMolecularEvolution.benchmark_grid-Tuple{Any}","page":"Home","title":"CodonMolecularEvolution.benchmark_grid","text":"CodonMolecularEvolution.benchmark_grid(benchmark_name; exports=true, versions_option=1, t::Integer=0, data=1:5)\n\nBenchmarks different implementations of the difFUBAR_grid algorithm. Results of the benchmark are printed out as a DataFrame and saved to a CSV file.\n\nbenchmark_name is the filepath to where the benchmark will be saved, if exports\nversions_option have 4 different options:\ndefault option, only run heuristic top pick\nonly run baseline version\nrun heuristic top pick and baseline version\nrun all versions\nt is the number of threads you want to use in the parallel versions. If specified and non-zero, this will override the number of threads chosen by the heuristic.\ndata is the range/vector of datasets to run the benchmark on. By default, this is 1:5. These are the enumerated datasets:\nAce2nobackground\nAce2reallytiny\nAce2tiny\nParvoVP\nParvoVPregrouped\n\n\n\n\n\n","category":"method"},{"location":"#CodonMolecularEvolution.dNdS-Tuple{Any, Any, Vector{Float64}}","page":"Home","title":"CodonMolecularEvolution.dNdS","text":"dNdS(q1, q0, p; code = MolecularEvolution.universal_code)\ndNdS(q1, q0; code = MolecularEvolution.universal_code)\n\nReturns an analytic expectation of the dN/dS ratio for a codon model. q1 is the rate matrix where selection is active (eg. a Halpern and Bruno model with a set of fitnesses), and q0 is the corresponding rate matrix where selection is inactive (eg. a Halpern and Bruno model with all fitnesses equal). p is the frequency distribution over codons that the dN/dS ratio is computed against. If not provided, this is computed as the equilibrium from q1. If only a vector of fitnesses are provided, then the q1, q0, and p are computed assuming a Halpern and Bruno model.\n\nfs = randn(20)\nnucm = CodonMolecularEvolution.demo_nucmat\nq1 = HB98AA_matrix(1.0, nucm, fs)\nq0 = HB98AA_matrix(1.0, nucm, zeros(20))\ndNdS(q1, q0)\n\n\n\n\n\n","category":"method"},{"location":"#CodonMolecularEvolution.difFUBAR-NTuple{5, Any}","page":"Home","title":"CodonMolecularEvolution.difFUBAR","text":"difFUBAR(seqnames, seqs, treestring, tags, outpath; <keyword arguments>)\n\nTakes a tagged phylogeny and an alignment as input and performs difFUBAR analysis. Returns df, results_tuple where df is a DataFrame of the detected sites and results_tuple is a tuple of the partial calculations needed to re-run difFUBAR_tabulate. Consistent with the docs of difFUBAR_tabulate, results_tuple stores (alloc_grid, codon_param_vec, alphagrid, omegagrid, tag_colors).\n\nArguments\n\nseqnames: vector of untagged sequence names.\nseqs: vector of aligned sequences, corresponding to seqnames.\ntreestring: a tagged newick tree string.\ntags: vector of tag signatures.\noutpath: export directory.\ntag_colors=DIFFUBAR_TAG_COLORS[sortperm(tags)]: vector of tag colors (hex format). The default option is consistent with the difFUBAR paper (Foreground 1: red, Foreground 2: blue).\npos_thresh=0.95: threshold of significance for the posteriors.\niters=2500: iterations used in the Gibbs sampler.\nbinarize=false: if true, the tree is binarized before the analysis.\nverbosity=1: as verbosity increases, prints are added accumulatively. \n0 - no prints\n1 - show current step and where output files are exported\n2 - show the chosen difFUBAR_grid version and amount of parallel threads.\nexports=true: if true, output files are exported.\ncode=MolecularEvolution.universal_code: genetic code used for the analysis.\noptimize_branch_lengths=false: if true, the branch lengths of the phylogenetic tree are optimized.\nversion::Union{difFUBARGrid, Nothing}=nothing: explicitly choose the version of difFUBAR_grid to use. If nothing, the version is heuristically chosen based on the available RAM and Julia threads.\nt=0: explicitly choose the amount of Julia threads to use. If 0, the degree of parallelization is heuristically chosen based on the available RAM and Julia threads.\n\nnote: Note\nJulia starts up with a single thread of execution, by default. See Starting Julia with multiple threads.\n\n\n\n\n\n","category":"method"},{"location":"#CodonMolecularEvolution.difFUBAR_init-Tuple{Any, Any, Any}","page":"Home","title":"CodonMolecularEvolution.difFUBAR_init","text":"\n\n\n\n","category":"method"},{"location":"#CodonMolecularEvolution.difFUBAR_tabulate-NTuple{6, Any}","page":"Home","title":"CodonMolecularEvolution.difFUBAR_tabulate","text":"difFUBAR_tabulate(analysis_name, pos_thresh, alloc_grid, codon_param_vec, alphagrid, omegagrid; tag_colors=DIFFUBAR_TAG_COLORS, verbosity=1, sites_to_plot=nothing, exports=true)\n\nTakes the output of difFUBAR and tabulates the results. Returns a DataFrame of the detected sites. This function enables you to use the results of difFUBAR to tabulate the results with a different threshold.\n\nArguments\n\nanalysis_name: where to export the results.\npos_thresh: threshold of significance for the posteriors.\nalloc_grid: contains the result of the Gibbs sampler.\ncodon_param_vec: vector of codon parameters from difFUBAR.\nalphagrid: grid of alpha values.\nomegagrid: grid of omega values.\ntag_colors: colors of the tags.\n\n\n\n\n\n","category":"method"},{"location":"#CodonMolecularEvolution.getpuresubclades-Tuple{MolecularEvolution.FelNode, Vector{String}}","page":"Home","title":"CodonMolecularEvolution.getpuresubclades","text":"getpuresubclades(tree::FelNode, tags::Vector{String})\n\nShould usually be called on the root of the tree. Traverses the tree iteratively with a depth-first search to find roots of pure subclades, presuming that nodenames have been trailed with tags. Returns a Vector{FelNode} with root-nodes of the pure subclades.\n\n\n\n\n\n","category":"method"},{"location":"#CodonMolecularEvolution.import_colored_figtree_nexus_as_tagged_tree-Tuple{Any}","page":"Home","title":"CodonMolecularEvolution.import_colored_figtree_nexus_as_tagged_tree","text":"import_colored_figtree_nexus_as_tagged_tree(fname; custom_labels=String[])\n\nTakes a nexus file from FigTree, where branches have been colored. Replaces all color tags with group tags that can be used in the models. Can add custom labels too. Should consider an entire custom dictionary as well in future.\n\nExamples\n\njulia> treestring, tags, tag_colors = import_colored_figtree_nexus_as_tagged_tree(\"data/Ace2_no_background.nex\")\n(\"(((XM_027533928_Bos_indicus_x_Bos_taurus{G1}:0.097072,(XM_042974087_Panthera_tigris{G1}:0.038016,... more ...;\", [\"{G2}\", \"{G1}\"], [\"#ff0015\", \"#0011ff\"])\n\nnote: Note\ntreestring is truncated. NEXUS tree file\n\n\n\n\n\n","category":"method"},{"location":"#CodonMolecularEvolution.import_grouped_label_tree-Tuple{Any}","page":"Home","title":"CodonMolecularEvolution.import_grouped_label_tree","text":"import_grouped_label_tree(tree_file)\n\nTakes a Newick tree file and return Newick tree, Newick tree with replaced tags, group tags, original tags, and randomly generated colours for each tag\n\n\n\n\n\n","category":"method"},{"location":"#CodonMolecularEvolution.import_labeled_phylotree_newick-Tuple{Any}","page":"Home","title":"CodonMolecularEvolution.import_labeled_phylotree_newick","text":"import_labeled_phylotree_newick(fname)\n\nImport a tagged phylogeny from phylotree and return the treestring and tags.\n\n\n\n\n\n","category":"method"},{"location":"#CodonMolecularEvolution.jump-Tuple{Any, Any, PiecewiseOUModel}","page":"Home","title":"CodonMolecularEvolution.jump","text":"jump(x_source, m::PiecewiseOUModel)\n\nEvolves values over time using a piecewise constant approximation to an OU process, where this function computes the new distribution for a single discrete jump. x_source is the vector of fitnesses, and m is the PiecewiseOUModel.\n\n\n\n\n\n","category":"method"},{"location":"#CodonMolecularEvolution.jumpy_HB_codon_evolve-NTuple{6, Any}","page":"Home","title":"CodonMolecularEvolution.jumpy_HB_codon_evolve","text":"jumpy_HB_codon_evolve(fitnesses, codon, ou_model, nuc_matrix, alpha, time;\n    genetic_code = MolecularEvolution.universal_code, push_into = nothing)\n\nEvolves fitnesses and codons over time using the HB98 model. fitnesses is the vector of fitnesses, codon is the current codon, ou_model is the OU model, nuc_matrix is the symmetric nucleotide substitution matrix, alpha is the synonymous rate, and time is the total time to evolve over.\n\n\n\n\n\n","category":"method"},{"location":"#CodonMolecularEvolution.jumpy_NeHB_codon_evolve-NTuple{6, Any}","page":"Home","title":"CodonMolecularEvolution.jumpy_NeHB_codon_evolve","text":"jumpy_NeHB_codon_evolve(fitnesses, logNe_trajectory, codon, fitness_model, nuc_matrix, alpha;\ngenetic_code = MolecularEvolution.universal_code, push_into = nothing)\n\nEvolves codons and unscaled site-fitness, along with a given trajectory of log-pop-size.\n\n\n\n\n\n","category":"method"},{"location":"#CodonMolecularEvolution.maxdNdS2std-Tuple{Any}","page":"Home","title":"CodonMolecularEvolution.maxdNdS2std","text":"maxdNdS2std(ω)\n\nInverse of std2maxdNdS(σ). Estimates the standard deviation of the fitnesses that will produce, in expectation, a dN/dS ratio of ω, assuming Gaussian fitnesses and a Halpern and Bruno model, where the fitnesses have just shifted from one Gaussian sample to another. Note: this is not an analytical solution, but a serindipitously good approximation.\n\n\n\n\n\n","category":"method"},{"location":"#CodonMolecularEvolution.optimize_MG94_F3x4-Tuple{Any, Any, Any}","page":"Home","title":"CodonMolecularEvolution.optimize_MG94_F3x4","text":"optimize_MG94_F3x4(seqnames, seqs, tree; leaf_name_transform=x -> x, genetic_code=MolecularEvolution.universal_code)\n\nOptimizes the MG94+F3x4 model on a tree, given a set of sequences and a tree. Returns the optimized tree, alpha, beta, nucmatrix, F3x4, and eqfreqs. The leafnametransform kwarg can be used to transform the leaf names in the tree to match the seqnames.\n\n\n\n\n\n","category":"method"},{"location":"#CodonMolecularEvolution.shiftingHBviz-NTuple{6, Any}","page":"Home","title":"CodonMolecularEvolution.shiftingHBviz","text":"shiftingHBviz(T, event_rate, σ, mixing_rate, alpha, nucm; T0 = -20)\n\nVisualize the fitness trajectory, codon frequencies, and expected dN/dS over time for a shifting HB process. T is the total time, event_rate is the rate of fitness shifts, σ is the standard deviation of the fitnesses, mixing_rate is the rate of mixing between fitnesses, alpha is the alpha parameter, and nucm is the nucleotide substitution matrix. T0 controls the burnin time, to ensure the process is at equilibrium at t=0.\n\nT = 2.0\nmix = 1.0\nσ = 5.0\nevent_rate = 100.0\nalpha = 1.0\nnucm = CodonMolecularEvolution.demo_nucmat\nshiftingHBviz(T, event_rate, σ, mix, alpha, nucm)\n\n\n\n\n\n","category":"method"},{"location":"#CodonMolecularEvolution.shiftingNeHBviz-NTuple{10, Any}","page":"Home","title":"CodonMolecularEvolution.shiftingNeHBviz","text":"shiftingNeHBviz(T, f_event_rate, f_σ, f_mixing_rate, logNe_event_rate, logNe_σ, logNe_mean, logNe_mixing_rate, alpha, nucm; T0 = -20)\n\nVisualize the Ne trajectory, fitness trajectory, codon frequencies, and expected dN/dS over time for a shifting Ne HB process.\n\n\n\n\n\n","category":"method"},{"location":"#CodonMolecularEvolution.sim_alphabeta_seqs-Tuple{Vector{Float64}, Vector{Float64}, Any, Matrix{Float64}, Matrix{Float64}}","page":"Home","title":"CodonMolecularEvolution.sim_alphabeta_seqs","text":"sim_alphabeta_seqs(alphavec::Vector{Float64}, betavec::Vector{Float64}, singletree, nucmat::Array{Float64,2}, f3x4::Array{Float64,2};\n                        scale_total_tree_neutral_expected_subs = -1.0, outpath = \"\")\n\nSimulate a set of sequences under a given tree, with a set of alpha and beta values. f3x4 is a 3-by-4 matrix of position-specific nucleotide frequencies. nucmat is a 4-by-4 matrix of nucleotide substitution rates. If scaletotaltreeneutralexpectedsubs > 0, then the tree is scaled so that if alpha=beta=1 for all sites, the expected number of neutral substitutions is equal to scaletotaltreeneutralexpectedsubs. The sequences are written to a fasta file, and the tree is written to a newick file.\n\n\n\n\n\n","category":"method"},{"location":"#CodonMolecularEvolution.std2maxdNdS-Tuple{Any}","page":"Home","title":"CodonMolecularEvolution.std2maxdNdS","text":"std2maxdNdS(σ)\n\nApproximation for the maximum dN/dS ratio as a function of the standard deviation of the fitnesses, assuming Gaussian fitnesses and a Halpern and Bruno model, where the fitnesses have just shifted from one Gaussian sample to another. Note: this is not an analytical solution, but a serindipitously good approximation.\n\nfunction monte_carlo_maxdNdS(σ; N=100_000)\n    sum_val = 0.0\n    for _ in 1:N\n        f_i = σ * randn()\n        f_j = σ * randn()\n        sum_val += HB_fixation_rate(f_i, f_j)\n    end\n    return sum_val / N\nend\nvs = 0:0.01:10\nplot(vs, monte_carlo_maxdNdS.(vs), label = \"Monte Carlo\", alpha = 0.8)\nplot!(vs, std2maxdNdS.(vs), label = \"Approx\", linestyle = :dash, alpha = 0.8)\n\n\n\n\n\n","category":"method"},{"location":"#CodonMolecularEvolution.time_varying_HB_freqs-NTuple{4, Any}","page":"Home","title":"CodonMolecularEvolution.time_varying_HB_freqs","text":"time_varying_HB_freqs(ts, T, fst, init_freqs; nucm = CodonMolecularEvolution.demo_nucmat, alpha = 1.0, delta_t = 0.002, prezero_delta_t = 0.5)\n\nCompute the time-varying codon frequencies and expected dN/dS over time for a sequence of fitnesses, under the Halpern-Bruno model. ts is a vector of times, T is the total time, fst is a vector of vector of fitnesses, init_freqs is the initial codon frequencies, nucm is the nucleotide substitution matrix, alpha is the alpha parameter, delta_t is the discretization time step for the simulation, and prezero_delta_t is the time step used before t=0. fst[i] is assumed to be the fitness between t = ts[i] and t = ts[i+1].\n\n\n\n\n\n","category":"method"},{"location":"#MolecularEvolution.forward!-Tuple{ShiftingNeHBSimPartition, ShiftingNeHBSimPartition, ShiftingNeHBSimModel, MolecularEvolution.FelNode}","page":"Home","title":"MolecularEvolution.forward!","text":"forward!(dest, source, model, node)\n\nEvolves source partition along node.branchlength under model, storing the result in dest.\n\n\n\n\n\n","category":"method"}]
}

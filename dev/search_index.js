var documenterSearchIndex = {"docs":
[{"location":"shared/#Shared-tools","page":"Shared tools","title":"Shared tools","text":"","category":"section"},{"location":"shared/","page":"Shared tools","title":"Shared tools","text":"These tools are shared between the models.","category":"page"},{"location":"shared/#Tree-importing","page":"Shared tools","title":"Tree importing","text":"","category":"section"},{"location":"shared/","page":"Shared tools","title":"Shared tools","text":"import_colored_figtree_nexus_as_tagged_tree\nimport_grouped_label_tree","category":"page"},{"location":"shared/#CodonMolecularEvolution.import_colored_figtree_nexus_as_tagged_tree","page":"Shared tools","title":"CodonMolecularEvolution.import_colored_figtree_nexus_as_tagged_tree","text":"import_colored_figtree_nexus_as_tagged_tree(fname; custom_labels=String[])\n\nTakes a nexus file from FigTree, where branches have been colored. Replaces all color tags with group tags that can be used in the models. Can add custom labels too. Should consider an entire custom dictionary as well in future.\n\nExamples\n\njulia> treestring, tags, tag_colors = import_colored_figtree_nexus_as_tagged_tree(\"data/Ace2_no_background.nex\")\n(\"(((XM_027533928_Bos_indicus_x_Bos_taurus{G1}:0.097072,(XM_042974087_Panthera_tigris{G1}:0.038016,... more ...;\", [\"{G2}\", \"{G1}\"], [\"#ff0015\", \"#0011ff\"])\n\nnote: Note\ntreestring is truncated. NEXUS tree file\n\n\n\n\n\n","category":"function"},{"location":"shared/#CodonMolecularEvolution.import_grouped_label_tree","page":"Shared tools","title":"CodonMolecularEvolution.import_grouped_label_tree","text":"import_grouped_label_tree(tree_file)\n\nTakes a Newick tree file and return Newick tree, Newick tree with replaced tags, group tags, original tags, and randomly generated colours for each tag\n\n\n\n\n\n","category":"function"},{"location":"shared/#Model-fitting","page":"Shared tools","title":"Model fitting","text":"","category":"section"},{"location":"shared/","page":"Shared tools","title":"Shared tools","text":"CodonMolecularEvolution.optimize_MG94_F3x4","category":"page"},{"location":"shared/#CodonMolecularEvolution.optimize_MG94_F3x4","page":"Shared tools","title":"CodonMolecularEvolution.optimize_MG94_F3x4","text":"optimize_MG94_F3x4(seqnames, seqs, tree; leaf_name_transform=x -> x, genetic_code=MolecularEvolution.universal_code)\n\nOptimizes the MG94+F3x4 model on a tree, given a set of sequences and a tree. Returns the optimized tree, alpha, beta, nucmatrix, F3x4, and eqfreqs. The leafnametransform kwarg can be used to transform the leaf names in the tree to match the seqnames.\n\n\n\n\n\n","category":"function"},{"location":"shared/#Misc","page":"Shared tools","title":"Misc","text":"","category":"section"},{"location":"difFUBAR/#difFUBAR","page":"difFUBAR","title":"difFUBAR","text":"","category":"section"},{"location":"difFUBAR/","page":"difFUBAR","title":"difFUBAR","text":"An interface to difFUBAR (awaiting the correct link)","category":"page"},{"location":"difFUBAR/#Example","page":"difFUBAR","title":"Example","text":"","category":"section"},{"location":"difFUBAR/","page":"difFUBAR","title":"difFUBAR","text":"Reads codon sequences from this FASTA file, and a tagged phylogeny from this NEXUS tree file.","category":"page"},{"location":"difFUBAR/","page":"difFUBAR","title":"difFUBAR","text":"using MolecularEvolution, FASTX, CodonMolecularEvolution\nanalysis_name = \"output/Ace2\"\nseqnames,seqs = read_fasta(\"data/Ace2_tiny_test.fasta\");\ntreestring, tags, tag_colors = import_colored_figtree_nexus_as_tagged_tree(\"data/Ace2_no_background.nex\")\ndf,results = difFUBAR(seqnames, seqs, treestring, tags, tag_colors, analysis_name);","category":"page"},{"location":"difFUBAR/","page":"difFUBAR","title":"difFUBAR","text":"Step 1: Initialization. If exports = true, tree showing the assignment of branches to groups/colors will be exported to: output/Ace2_tagged_input_tree.svg.\nStep 2: Optimizing global codon model parameters.\n0.0% 29.0% 58.0% 87.0% \nStep 4: Running Gibbs sampler to infer site categories.\nStep 5: Tabulating and plotting. Detected sites:\nSite 3 - P(ω1 > ω2):0.0045; P(ω2 > ω1):0.9805; P(ω1 > 1):0.1375; P(ω2 > 1):0.975\nSite 13 - P(ω1 > ω2):0.019; P(ω2 > ω1):0.9605; P(ω1 > 1):0.1435; P(ω2 > 1):0.9295\n\nIf exports = true, writing results for all sites to CSV: output/Ace2_posteriors.csv\nPlotting alpha and omega distributions. If exports = true, saved as output/Ace2_violin_*.pdf","category":"page"},{"location":"difFUBAR/","page":"difFUBAR","title":"difFUBAR","text":"Here's a selection of the output files:","category":"page"},{"location":"difFUBAR/","page":"difFUBAR","title":"difFUBAR","text":"output/Ace2_tagged_input_tree.svg","category":"page"},{"location":"difFUBAR/","page":"difFUBAR","title":"difFUBAR","text":"(Image: )","category":"page"},{"location":"difFUBAR/","page":"difFUBAR","title":"difFUBAR","text":"note: Note\ndifFUBAR allows for an optional, untagged, background branch set.","category":"page"},{"location":"difFUBAR/","page":"difFUBAR","title":"difFUBAR","text":"output/Ace2_site_omega_means.pdf","category":"page"},{"location":"difFUBAR/","page":"difFUBAR","title":"difFUBAR","text":"(Image: )","category":"page"},{"location":"difFUBAR/","page":"difFUBAR","title":"difFUBAR","text":"output/Ace2_violin_all_params.pdf","category":"page"},{"location":"difFUBAR/","page":"difFUBAR","title":"difFUBAR","text":"(Image: )","category":"page"},{"location":"difFUBAR/","page":"difFUBAR","title":"difFUBAR","text":"note: Note\nThe output has a stochastic element to it due to the MCMC.","category":"page"},{"location":"difFUBAR/#Interface","page":"difFUBAR","title":"Interface","text":"","category":"section"},{"location":"difFUBAR/","page":"difFUBAR","title":"difFUBAR","text":"difFUBAR","category":"page"},{"location":"difFUBAR/#CodonMolecularEvolution.difFUBAR","page":"difFUBAR","title":"CodonMolecularEvolution.difFUBAR","text":"difFUBAR(seqnames, seqs, treestring, tags, tag_colors, outpath; <keyword arguments>)\n\nTakes a tagged phylogeny and an alignment as input and performs difFUBAR analysis.\n\nArguments\n\nseqnames: vector of untagged sequence names.\nseqs: vector of aligned sequences, corresponding to seqnames.\ntreestring: a tagged newick tree string.\ntags: vector of tag signatures.\ntag_colors: vector of tag colors (hex format).\noutpath: export directory.\npos_thresh=0.95: threshold of significance for the posteriors.\niters=2500: iterations used in the Gibbs sampler.\nverbosity=1: as verbosity increases, prints are added accumulatively. \n0 - no prints\n1 - show current step and where output files are exported\n2 - show the chosen difFUBAR_grid version and amount of parallel threads.\nexports=true: if true, output files are exported.\ncode=MolecularEvolution.universal_code: genetic code used for the analysis.\noptimize_branch_lengths=false: if true, the branch lengths of the phylogenetic tree are optimized.\nversion::Union{difFUBARGrid, Nothing}=nothing: explicitly choose the version of difFUBAR_grid to use. If nothing, the version is heuristically chosen based on the available RAM and Julia threads.\nt=0: explicitly choose the amount of Julia threads to use. If 0, the degree of parallelization is heuristically chosen based on the available RAM and Julia threads.\n\nnote: Note\nJulia starts up with a single thread of execution, by default. See Starting Julia with multiple threads.\n\n\n\n\n\n","category":"function"},{"location":"difFUBAR/#For-a-simple-and-often-optimal-configuration","page":"difFUBAR","title":"For a simple and often optimal configuration","text":"","category":"section"},{"location":"difFUBAR/","page":"difFUBAR","title":"difFUBAR","text":"Launch Julia in the following manner: julia -t auto\nKeep the default values of the kwargs version and t","category":"page"},{"location":"difFUBAR/","page":"difFUBAR","title":"difFUBAR","text":"This lets Julia decide the amount of Julia threads and lets CodonMolecularEvolution.jl decide the difFUBARGrid subtype to dispatch on and the degree of parallelization.","category":"page"},{"location":"difFUBAR/#difFUBARGrid","page":"difFUBAR","title":"difFUBARGrid","text":"","category":"section"},{"location":"difFUBAR/","page":"difFUBAR","title":"difFUBAR","text":"Subtypes that decide which method to use for the grid likelihood computations.","category":"page"},{"location":"difFUBAR/","page":"difFUBAR","title":"difFUBAR","text":"difFUBARBaseline\ndifFUBARParallel\ndifFUBARTreesurgery\ndifFUBARTreesurgeryAndParallel","category":"page"},{"location":"difFUBAR/#CodonMolecularEvolution.difFUBARBaseline","page":"difFUBAR","title":"CodonMolecularEvolution.difFUBARBaseline","text":"Constructor\n\ndifFUBARBaseline()\n\nDescription\n\nUse the trivial implementation of the grid likelihood computations, i.e. 1 thread without sub-tree likelihood caching.\n\nSee also: difFUBARParallel, difFUBARTreesurgery, difFUBARTreesurgeryAndParallel.\n\n\n\n\n\n","category":"type"},{"location":"difFUBAR/#CodonMolecularEvolution.difFUBARParallel","page":"difFUBAR","title":"CodonMolecularEvolution.difFUBARParallel","text":"Constructor\n\ndifFUBARParallel()\n\nDescription\n\nExtend the baseline version by parallelizing the grid calculations. Requires julia to be launched with the t switch. Using t computational threads, where t is sufficiently small, memory complexity is usually O(t) and time complexity O(1/t). Empirical tests suggests that t should not be higher than the machine's total CPU threads and usually not higher than half of it's total threads.\n\nSee also: difFUBARBaseline, difFUBARTreesurgery, difFUBARTreesurgeryAndParallel.\n\n\n\n\n\n","category":"type"},{"location":"difFUBAR/#CodonMolecularEvolution.difFUBARTreesurgery","page":"difFUBAR","title":"CodonMolecularEvolution.difFUBARTreesurgery","text":"Constructor\n\ndifFUBARTreesurgery()\n\nDescription\n\nUse sub-tree likelihood caching described in the \"Methods\" section of the difFUBAR paper. Use more memory than the baseline version but be significantly faster, if purity is high.\n\nSee also: difFUBARBaseline, difFUBARParallel, difFUBARTreesurgeryAndParallel.\n\n\n\n\n\n","category":"type"},{"location":"difFUBAR/#CodonMolecularEvolution.difFUBARTreesurgeryAndParallel","page":"difFUBAR","title":"CodonMolecularEvolution.difFUBARTreesurgeryAndParallel","text":"Constructor\n\ndifFUBARTreesurgeryAndParallel()\n\nDescription\n\nUse parallelization and sub-tree likelihood caching. The most performant version in most cases. Use more memory than other versions.\n\nSee also: difFUBARBaseline, difFUBARTreesurgery, difFUBARParallel.\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = CodonMolecularEvolution","category":"page"},{"location":"#CodonMolecularEvolution","page":"Home","title":"CodonMolecularEvolution","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for CodonMolecularEvolution.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Descendant of MolecularEvolution.jl, specializing in codon models.","category":"page"},{"location":"#A-Julia-package-that-contains-a-collection-of-popular/(state-of-the-art)-codon-model-methods.","page":"Home","title":"A Julia package that contains a collection of popular/(state of the art) codon model methods.","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CodonMolecularEvolution.jl leverages the MolecularEvolution.jl framework to provide a performant interface to some codon model methods that are used for phylogenetic analysis.","category":"page"},{"location":"#Collection-of-codon-model-methods","page":"Home","title":"Collection of codon model methods","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"difFUBAR: Scalable Bayesian comparison of selection pressure\nPerform a site-wise comparison of evolutionary pressure between two selected sets of branches.","category":"page"},{"location":"#Design-principles","page":"Home","title":"Design principles","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Specificity\nWe keep our implementations on a high level of abstraction and let MolecularEvolution.jl take care of the low-level behaviour.\nScalability\nOur exported codon model methods should scale to large, real-world datasets. To keep the memory footprint down, we use MolecularEvolution.jls LazyPartition when possible.\nPerformance\nWhile scalability takes precedence over speed?, we try to maintain competitive runtimes by using e.g. computational shortcuts and parallelization whenever we can.","category":"page"},{"location":"#Authors","page":"Home","title":"Authors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Ben decides what to put here.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [CodonMolecularEvolution]","category":"page"},{"location":"#CodonMolecularEvolution.benchmark_global_fit-Tuple{Any}","page":"Home","title":"CodonMolecularEvolution.benchmark_global_fit","text":"CodonMolecularEvolution.benchmark_global_fit(benchmark_name; exports=true, data=1:5, optimize_branch_lengths=false)\n\nBenchmarks different implementations of the difFUBARglobalfit algorithm. Results of the benchmark are printed out as a DataFrame and saved to a CSV file.  Uses the heuristic top pick to generate con lik matrices. Compares difference in con lik matrices. If exports is true, it also runs MCMCs on the con lik matrices and plots the means and posteriors of the different versions.\n\nbenchmark_name is the filepath to where the benchmark will be saved, if exports.\ndata is the range/vector of datasets to run the benchmark on. By default, this is 1:5. These are the enumerated datasets:\nAce2nobackground\nAce2reallytiny\nAce2tiny\nParvoVP\nParvoVPregrouped\noptimize_branch_lengths is an option that can be either true, false or \"detect\"\n\n\n\n\n\n","category":"method"},{"location":"#CodonMolecularEvolution.benchmark_grid-Tuple{Any}","page":"Home","title":"CodonMolecularEvolution.benchmark_grid","text":"CodonMolecularEvolution.benchmark_grid(benchmark_name; exports=true, versions_option=1, t::Integer=0, data=1:5)\n\nBenchmarks different implementations of the difFUBAR_grid algorithm. Results of the benchmark are printed out as a DataFrame and saved to a CSV file.\n\nbenchmark_name is the filepath to where the benchmark will be saved, if exports\nversions_option have 4 different options:\ndefault option, only run heuristic top pick\nonly run baseline version\nrun heuristic top pick and baseline version\nrun all versions\nt is the number of threads you want to use in the parallel versions. If specified and non-zero, this will override the number of threads chosen by the heuristic.\ndata is the range/vector of datasets to run the benchmark on. By default, this is 1:5. These are the enumerated datasets:\nAce2nobackground\nAce2reallytiny\nAce2tiny\nParvoVP\nParvoVPregrouped\n\n\n\n\n\n","category":"method"},{"location":"#CodonMolecularEvolution.difFUBAR-NTuple{6, Any}","page":"Home","title":"CodonMolecularEvolution.difFUBAR","text":"difFUBAR(seqnames, seqs, treestring, tags, tag_colors, outpath; <keyword arguments>)\n\nTakes a tagged phylogeny and an alignment as input and performs difFUBAR analysis.\n\nArguments\n\nseqnames: vector of untagged sequence names.\nseqs: vector of aligned sequences, corresponding to seqnames.\ntreestring: a tagged newick tree string.\ntags: vector of tag signatures.\ntag_colors: vector of tag colors (hex format).\noutpath: export directory.\npos_thresh=0.95: threshold of significance for the posteriors.\niters=2500: iterations used in the Gibbs sampler.\nverbosity=1: as verbosity increases, prints are added accumulatively. \n0 - no prints\n1 - show current step and where output files are exported\n2 - show the chosen difFUBAR_grid version and amount of parallel threads.\nexports=true: if true, output files are exported.\ncode=MolecularEvolution.universal_code: genetic code used for the analysis.\noptimize_branch_lengths=false: if true, the branch lengths of the phylogenetic tree are optimized.\nversion::Union{difFUBARGrid, Nothing}=nothing: explicitly choose the version of difFUBAR_grid to use. If nothing, the version is heuristically chosen based on the available RAM and Julia threads.\nt=0: explicitly choose the amount of Julia threads to use. If 0, the degree of parallelization is heuristically chosen based on the available RAM and Julia threads.\n\nnote: Note\nJulia starts up with a single thread of execution, by default. See Starting Julia with multiple threads.\n\n\n\n\n\n","category":"method"},{"location":"#CodonMolecularEvolution.difFUBAR_init-NTuple{4, Any}","page":"Home","title":"CodonMolecularEvolution.difFUBAR_init","text":"\n\n\n\n","category":"method"},{"location":"#CodonMolecularEvolution.getpuresubclades-Tuple{MolecularEvolution.FelNode, Vector{String}}","page":"Home","title":"CodonMolecularEvolution.getpuresubclades","text":"getpuresubclades(tree::FelNode, tags::Vector{String})\n\nShould usually be called on the root of the tree. Traverses the tree iteratively with a depth-first search to find roots of pure subclades, presuming that nodenames have been trailed with tags. Returns a Vector{FelNode} with root-nodes of the pure subclades.\n\n\n\n\n\n","category":"method"},{"location":"#CodonMolecularEvolution.import_colored_figtree_nexus_as_tagged_tree-Tuple{Any}","page":"Home","title":"CodonMolecularEvolution.import_colored_figtree_nexus_as_tagged_tree","text":"import_colored_figtree_nexus_as_tagged_tree(fname; custom_labels=String[])\n\nTakes a nexus file from FigTree, where branches have been colored. Replaces all color tags with group tags that can be used in the models. Can add custom labels too. Should consider an entire custom dictionary as well in future.\n\nExamples\n\njulia> treestring, tags, tag_colors = import_colored_figtree_nexus_as_tagged_tree(\"data/Ace2_no_background.nex\")\n(\"(((XM_027533928_Bos_indicus_x_Bos_taurus{G1}:0.097072,(XM_042974087_Panthera_tigris{G1}:0.038016,... more ...;\", [\"{G2}\", \"{G1}\"], [\"#ff0015\", \"#0011ff\"])\n\nnote: Note\ntreestring is truncated. NEXUS tree file\n\n\n\n\n\n","category":"method"},{"location":"#CodonMolecularEvolution.import_grouped_label_tree-Tuple{Any}","page":"Home","title":"CodonMolecularEvolution.import_grouped_label_tree","text":"import_grouped_label_tree(tree_file)\n\nTakes a Newick tree file and return Newick tree, Newick tree with replaced tags, group tags, original tags, and randomly generated colours for each tag\n\n\n\n\n\n","category":"method"},{"location":"#CodonMolecularEvolution.optimize_MG94_F3x4-Tuple{Any, Any, Any}","page":"Home","title":"CodonMolecularEvolution.optimize_MG94_F3x4","text":"optimize_MG94_F3x4(seqnames, seqs, tree; leaf_name_transform=x -> x, genetic_code=MolecularEvolution.universal_code)\n\nOptimizes the MG94+F3x4 model on a tree, given a set of sequences and a tree. Returns the optimized tree, alpha, beta, nucmatrix, F3x4, and eqfreqs. The leafnametransform kwarg can be used to transform the leaf names in the tree to match the seqnames.\n\n\n\n\n\n","category":"method"}]
}
